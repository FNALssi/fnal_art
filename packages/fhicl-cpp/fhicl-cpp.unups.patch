diff --git a/CMakeLists.txt b/CMakeLists.txt
index 22b8f43..6c85e3c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,12 +14,12 @@
 #  make install
 #  make package (builds distribution tarfile)
 
-cmake_minimum_required(VERSION 3.11)  # use cmake 3.11 or later
+cmake_minimum_required(VERSION 3.12...3.14 FATAL_ERROR)
 
-project(fhiclcpp)
+project(fhiclcpp VERSION 4.11.01 LANGUAGES CXX)
 
-# cetbuildtools contains our cmake modules
-find_package(cetbuildtools 7.13.01 REQUIRED)
+# cetmodules contains our cmake modules
+find_package(cetmodules 1.01.01 REQUIRED)
 
 include(CetCMakeEnv)
 cet_cmake_env()
@@ -28,55 +28,26 @@ cet_set_compiler_flags(DIAGS VIGILANT
   WERROR
   NO_UNDEFINED
   EXTRA_FLAGS -pedantic
-  EXTRA_CXX_FLAGS -Wnon-virtual-dtor -Wdelete-non-virtual-dtor
+  EXTRA_CXX_FLAGS -Wnon-virtual-dtor -Wdelete-non-virtual-dtor -DBOOST_TEST_NO_OLD_TOOLS
   )
 
-if($ENV{CET_SANITIZE_ADDRESS})
-  if(NOT "$ENV{GCC_FQ_DIR}" STREQUAL "")
-    find_file(ASAN_LIB libasan.so NO_DEFAULT_PATH PATHS $ENV{GCC_FQ_DIR}/lib64)
-  endif()
-endif()
-
-if($ENV{CET_SANITIZE_THREAD})
-  if(NOT "$ENV{GCC_FQ_DIR}" STREQUAL "")
-    find_file(TSAN_LIB libtsan.so NO_DEFAULT_PATH PATHS $ENV{GCC_FQ_DIR}/lib64)
-  endif()
-endif()
-
-if ($ENV{CET_SANITIZE_ADDRESS})
-cet_add_compiler_flags(CXX -fsanitize=address)
-cet_add_compiler_flags(C -fsanitize=address)
-set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} -fsanitize=address")
-set(CMAKE_MODULE_LINKER_FLAGS_DEBUG "${CMAKE_MODULE_LINKER_FLAGS_DEBUG} -fsanitize=address")
-set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} -fsanitize=address")
-endif()
-
-if ($ENV{CET_SANITIZE_THREAD})
-cet_add_compiler_flags(CXX -fsanitize=thread -D__SANITIZE_THREAD__)
-cet_add_compiler_flags(C -fsanitize=thread -D__SANITIZE_THREAD__)
-set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} -fsanitize=thread -D__SANITIZE_THREAD__")
-set(CMAKE_MODULE_LINKER_FLAGS_DEBUG "${CMAKE_MODULE_LINKER_FLAGS_DEBUG} -fsanitize=thread -D__SANITIZE_THREAD__")
-set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} -fsanitize=thread -D__SANITIZE_THREAD__")
-endif()
-
 cet_report_compiler_flags()
 
 
-# these are minimum required versions, not the actual product versions
-find_ups_product(cetlib_except v1_00_00)
-find_ups_product(cetlib v2_01_00)
-find_ups_product(python)
-find_ups_product(sqlite v3_07_15_00)
-find_ups_boost(BOOST_TARGETS v1_50_0)
+# Both of these are needed to ensure sane and consistent Python
+# location, even though we don't actually need the interpreter.
+find_package(PythonInterp REQUIRED)
+find_package(PythonLibs REQUIRED)
 
-# SQLite
-cet_find_library(SQLITE3 NAMES sqlite3_ups PATHS ENV SQLITE_LIB NO_DEFAULT_PATH)
+# Other required components.
+find_package(hep_concurrency REQUIRED)
+find_package(cetlib_except REQUIRED)
+find_package(cetlib REQUIRED)
+find_package(Boost 1.50.0 REQUIRED COMPONENTS program_options)
+find_library(SQLITE3 NAMES sqlite3 REQUIRED)
 
 # source code
 add_subdirectory(fhiclcpp)
 add_subdirectory(python)
 add_subdirectory(tools)
-add_subdirectory(ups)
-
-# packaging utility
-include(UseCPack)
+add_subdirectory(cmakeConfig)
diff --git a/cmakeConfig/CMakeLists.txt b/cmakeConfig/CMakeLists.txt
new file mode 100644
index 0000000..937d12d
--- /dev/null
+++ b/cmakeConfig/CMakeLists.txt
@@ -0,0 +1,2 @@
+# Create package configuration and version files.
+cet_cmake_config()
diff --git a/cmakeConfig/fhiclcpp-fragment.cmake.in b/cmakeConfig/fhiclcpp-fragment.cmake.in
new file mode 100644
index 0000000..74caf8c
--- /dev/null
+++ b/cmakeConfig/fhiclcpp-fragment.cmake.in
@@ -0,0 +1,5 @@
+find_package(Boost 1.50.0 REQUIRED COMPONENTS)
+find_library(SQLITE3 NAMES sqlite3 REQUIRED)
+find_package(cetlib_except REQUIRED)
+find_package(cetlib REQUIRED)
+find_package(hep_concurrency REQUIRED)
diff --git a/fhiclcpp/parse_shims.h b/fhiclcpp/parse_shims.h
index 5761ec9..d1f5dae 100644
--- a/fhiclcpp/parse_shims.h
+++ b/fhiclcpp/parse_shims.h
@@ -107,3 +107,7 @@ namespace boost {
   }
 }
 #endif /* fhiclcpp_parse_shims_h */
+
+// Local Variables:
+// mode: c++
+// End:
diff --git a/fhiclcpp/parse_shims_opts.h b/fhiclcpp/parse_shims_opts.h
index 7305fab..f8c1d23 100644
--- a/fhiclcpp/parse_shims_opts.h
+++ b/fhiclcpp/parse_shims_opts.h
@@ -6,3 +6,7 @@ namespace shims {
 }
 
 #endif /* fhiclcpp_parse_shims_opts_h */
+
+// Local Variables:
+// mode: c++
+// End:
diff --git a/fhiclcpp/stdmap_shims.h b/fhiclcpp/stdmap_shims.h
index dd14349..1512102 100644
--- a/fhiclcpp/stdmap_shims.h
+++ b/fhiclcpp/stdmap_shims.h
@@ -352,3 +352,7 @@ namespace shims {
 }
 
 #endif /* fhiclcpp_stdmap_shims_h */
+
+// Local Variables:
+// mode: c++
+// End:
diff --git a/fhiclcpp/test/CMakeLists.txt b/fhiclcpp/test/CMakeLists.txt
index 1e609db..8e28c95 100644
--- a/fhiclcpp/test/CMakeLists.txt
+++ b/fhiclcpp/test/CMakeLists.txt
@@ -30,6 +30,8 @@ cet_test(get_sequence_elements_t USE_BOOST_UNIT
   DATAFILES Sample.cfg
 )
 
+cet_test(get_via_t USE_BOOST_UNIT)
+
 cet_test(equalTest USE_BOOST_UNIT)
 cet_test(failer DATAFILES test_config_fail.fcl)
 cet_test(fhicl-config_t NO_AUTO)
diff --git a/fhiclcpp/test/DatabaseSupport_t.cc b/fhiclcpp/test/DatabaseSupport_t.cc
index 20d814d..ec67426 100644
--- a/fhiclcpp/test/DatabaseSupport_t.cc
+++ b/fhiclcpp/test/DatabaseSupport_t.cc
@@ -16,8 +16,8 @@ BOOST_AUTO_TEST_CASE(no_nesting)
   std::vector<std::string> hashes;
 
   BOOST_CHECK_NO_THROW(fhicl::decompose_fhicl("db_0.fcl", records, hashes));
-  BOOST_CHECK_EQUAL(records.size(), hashes.size());
-  BOOST_CHECK_EQUAL(records.size(), 1ul);
+  BOOST_TEST(records.size() == hashes.size());
+  BOOST_TEST(records.size() == 1ul);
 }
 
 BOOST_AUTO_TEST_CASE(two_nested)
@@ -35,8 +35,8 @@ BOOST_AUTO_TEST_CASE(two_nested)
   std::cout << p.to_string() << std::endl;
 
   BOOST_CHECK_NO_THROW(fhicl::decompose_fhicl("db_1.fcl", records, hashes));
-  BOOST_CHECK_EQUAL(records.size(), hashes.size());
-  BOOST_CHECK_EQUAL(records.size(), 3ul);
+  BOOST_TEST(records.size() == hashes.size());
+  BOOST_TEST(records.size() == 3ul);
 }
 
 BOOST_AUTO_TEST_CASE(nested_vector)
@@ -51,11 +51,11 @@ BOOST_AUTO_TEST_CASE(nested_vector)
     p.get<std::vector<fhicl::ParameterSet>>("a");
   std::cout << "\n";
   std::cout << p.to_compact_string() << std::endl;
-  BOOST_CHECK_EQUAL(v.size(), 2ul);
+  BOOST_TEST(v.size() == 2ul);
 
   BOOST_CHECK_NO_THROW(fhicl::decompose_fhicl("db_2.fcl", records, hashes));
-  BOOST_CHECK_EQUAL(records.size(), hashes.size());
-  BOOST_CHECK_EQUAL(records.size(), 3ul);
+  BOOST_TEST(records.size() == hashes.size());
+  BOOST_TEST(records.size() == 3ul);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/ParameterSetRegistry_t.cc b/fhiclcpp/test/ParameterSetRegistry_t.cc
index a974c83..dcecda0 100644
--- a/fhiclcpp/test/ParameterSetRegistry_t.cc
+++ b/fhiclcpp/test/ParameterSetRegistry_t.cc
@@ -6,6 +6,7 @@
 #include "cetlib/container_algorithms.h"
 #include "fhiclcpp/ParameterSetRegistry.h"
 #include "fhiclcpp/make_ParameterSet.h"
+#include "fhiclcpp/test/boost_test_print_pset.h"
 #include "hep_concurrency/RecursiveMutex.h"
 
 #include "sqlite3.h"
@@ -42,18 +43,18 @@ BOOST_AUTO_TEST_CASE(Typedefs)
 
 BOOST_AUTO_TEST_CASE(MakeAndAdd)
 {
-  BOOST_REQUIRE(ParameterSetRegistry::empty());
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), 0ul);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::empty());
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == 0ul);
   ParameterSet pset;
   make_ParameterSet(
     "x: 5 y: { a: \"oops\" b: 9 } z: { c: \"Looooong striiiiiing.\" }", pset);
-  BOOST_REQUIRE(!ParameterSetRegistry::empty());
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), 2ul);
+  BOOST_TEST_REQUIRE(!ParameterSetRegistry::empty());
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == 2ul);
   ParameterSetRegistry::put(pset);
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), 3ul);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == 3ul);
   auto ps2 = ParameterSetRegistry::get(pset.id());
-  BOOST_REQUIRE_EQUAL(pset.id(), ps2.id());
-  BOOST_REQUIRE(pset == ps2);
+  BOOST_TEST_REQUIRE(pset.id() == ps2.id());
+  BOOST_TEST_REQUIRE(pset == ps2);
 }
 
 BOOST_AUTO_TEST_CASE(AddFromIterAndGet)
@@ -68,7 +69,7 @@ BOOST_AUTO_TEST_CASE(AddFromIterAndGet)
     make_ParameterSet(s, pset);
     v1.emplace_back(pset);
   }
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
   vector<ParameterSetRegistry::value_type> v2;
   string const f{"filler"};
   for (auto p : v1) {
@@ -77,22 +78,22 @@ BOOST_AUTO_TEST_CASE(AddFromIterAndGet)
   }
   expected_size += 3;
   ParameterSetRegistry::put(v1.cbegin(), v1.cend());
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
   expected_size += 3;
   ParameterSetRegistry::put(v2.cbegin(), v2.cend());
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
   ParameterSet pset;
   ParameterSetRegistry::get(v2.front().first, pset);
-  BOOST_REQUIRE(pset == v2.front().second);
+  BOOST_TEST_REQUIRE(pset == v2.front().second);
   auto p2 = ParameterSetRegistry::get(v2.back().first);
-  BOOST_REQUIRE(p2 == v2.back().second);
+  BOOST_TEST_REQUIRE(p2 == v2.back().second);
 }
 
 BOOST_AUTO_TEST_CASE(TestImport)
 {
   atomic<size_t> expected_size{ParameterSetRegistry::size()};
   sqlite3* db = nullptr;
-  BOOST_REQUIRE(!sqlite3_open(":memory:", &db));
+  BOOST_TEST_REQUIRE(!sqlite3_open(":memory:", &db));
   throwOnSQLiteFailure(db);
   char* errMsg = nullptr;
   sqlite3_exec(db,
@@ -174,11 +175,11 @@ BOOST_AUTO_TEST_CASE(TestImport)
       });
     cet::SimultaneousFunctionSpawner sfs{tasks};
   }
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
   ParameterSetRegistry::importFrom(db);
   // Make sure the registry didn't expand as a result of the insert.
-  BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
-  BOOST_REQUIRE_EQUAL(sqlite3_close(db), SQLITE_OK);
+  BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
+  BOOST_TEST_REQUIRE(sqlite3_close(db) == SQLITE_OK);
   // Read from registry in parallel
   {
     RecursiveMutex m{"ParameterSetRegistry_t::m"};
@@ -189,14 +190,14 @@ BOOST_AUTO_TEST_CASE(TestImport)
           // FIXME: Not thread-safe according to tsan!
           RecursiveMutexSentry sentry{m, "test"};
           // Should be in registry already.
-          BOOST_REQUIRE(ParameterSetRegistry::has(id));
+          BOOST_TEST_REQUIRE(ParameterSetRegistry::has(id));
         }
       } else {
         {
           // FIXME: Not thread-safe according to tsan!
           RecursiveMutexSentry sentry{m, "test"};
           // Make sure the import didn't inject them into the registry.
-          BOOST_REQUIRE(!ParameterSetRegistry::has(id));
+          BOOST_TEST_REQUIRE(!ParameterSetRegistry::has(id));
         }
         // We expect the get() call below to increase the size of the
         // registry by pulling the entry in from the backing DB.
@@ -206,7 +207,7 @@ BOOST_AUTO_TEST_CASE(TestImport)
         // FIXME: Not thread-safe according to tsan!
         RecursiveMutexSentry sentry{m, "test"};
         auto const& p2 = ParameterSetRegistry::get(id);
-        BOOST_REQUIRE(p2 == p.first);
+        BOOST_TEST_REQUIRE(p2 == p.first);
       }
     };
     vector<function<void()>> tasks;
@@ -215,14 +216,14 @@ BOOST_AUTO_TEST_CASE(TestImport)
         return [read_from_registry, p] { read_from_registry(p); };
       });
     cet::SimultaneousFunctionSpawner sfs{tasks};
-    BOOST_REQUIRE_EQUAL(ParameterSetRegistry::size(), expected_size);
+    BOOST_TEST_REQUIRE(ParameterSetRegistry::size() == expected_size);
   }
 }
 
 BOOST_AUTO_TEST_CASE(TestExport)
 {
   sqlite3* db = nullptr;
-  BOOST_REQUIRE(!sqlite3_open(":memory:", &db));
+  BOOST_TEST_REQUIRE(!sqlite3_open(":memory:", &db));
   // Check empty!
   sqlite3_stmt* stmt = nullptr;
   // Make sure we get our own fresh and empty DB.
@@ -232,15 +233,15 @@ BOOST_AUTO_TEST_CASE(TestExport)
     -1,
     &stmt,
     nullptr);
-  BOOST_REQUIRE_EQUAL(sqlite3_step(stmt), SQLITE_DONE); // No rows.
+  BOOST_TEST_REQUIRE(sqlite3_step(stmt) == SQLITE_DONE); // No rows.
   sqlite3_reset(stmt);
   ParameterSetRegistry::exportTo(db);
-  BOOST_REQUIRE_EQUAL(sqlite3_step(stmt), SQLITE_ROW); // Found table.
+  BOOST_TEST_REQUIRE(sqlite3_step(stmt) == SQLITE_ROW); // Found table.
   sqlite3_finalize(stmt);
   sqlite3_prepare_v2(
     db, "SELECT COUNT(*) from ParameterSets;", -1, &stmt, nullptr);
-  BOOST_REQUIRE_EQUAL(sqlite3_step(stmt), SQLITE_ROW);
-  BOOST_REQUIRE_EQUAL(sqlite3_column_int64(stmt, 0), 13l);
+  BOOST_TEST_REQUIRE(sqlite3_step(stmt) == SQLITE_ROW);
+  BOOST_TEST_REQUIRE(sqlite3_column_int64(stmt, 0) == 13l);
   sqlite3_finalize(stmt);
   sqlite3_close(db);
 }
diff --git a/fhiclcpp/test/ParameterSet_t.cc b/fhiclcpp/test/ParameterSet_t.cc
index ca67968..a1ffd38 100644
--- a/fhiclcpp/test/ParameterSet_t.cc
+++ b/fhiclcpp/test/ParameterSet_t.cc
@@ -4,6 +4,8 @@
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
+#include "fhiclcpp/test/boost_test_print_pset.h"
+
 #include <cstddef>
 #include <cstdlib>
 #include <string>
@@ -34,12 +36,12 @@ BOOST_AUTO_TEST_CASE(Local)
   fhicl::ParameterSet j;
   j.put("y", -1);
   fhicl::ParameterSet orig(pset.get<fhicl::ParameterSet>("j"));
-  BOOST_CHECK(j == orig);
-  BOOST_CHECK_EQUAL(orig.get<int>("y"), -1);
-  BOOST_CHECK_EQUAL(pset.get<std::vector<int>>("m")[0], -1);
+  BOOST_TEST(j == orig);
+  BOOST_TEST(orig.get<int>("y") == -1);
+  BOOST_TEST(pset.get<std::vector<int>>("m")[0] == -1);
 
   for (auto n : pset.get_names())
-    BOOST_CHECK("x" != n);
+    BOOST_TEST("x" != n);
 }
 
 BOOST_AUTO_TEST_CASE(DeepInjection)
@@ -49,23 +51,23 @@ BOOST_AUTO_TEST_CASE(DeepInjection)
   fhicl::ParameterSet k;
   k.put("l", l);
   fhicl::ParameterSet orig(pset.get<fhicl::ParameterSet>("k"));
-  BOOST_CHECK(k == orig);
-  BOOST_CHECK_EQUAL(orig.get<fhicl::ParameterSet>("l").get<int>("zz"), -2);
-  BOOST_CHECK_EQUAL(orig.get<int>("l.zz"), -2);
+  BOOST_TEST(k == orig);
+  BOOST_TEST(orig.get<fhicl::ParameterSet>("l").get<int>("zz") == -2);
+  BOOST_TEST(orig.get<int>("l.zz") == -2);
 }
 
 BOOST_AUTO_TEST_CASE(DoubleStringMismatchDefaulted)
 {
   std::string s;
   BOOST_CHECK_MESSAGE(pset.get_if_present("e", s), "Failed to get string");
-  BOOST_CHECK_EQUAL(s, "rain");
+  BOOST_TEST(s == "rain");
 
   try {
     pset.get<double>("e", 2.0);
     BOOST_FAIL("Failed to throw an exception as expected");
   }
   catch (fhicl::exception& e) {
-    BOOST_CHECK_EQUAL(e.categoryCode(), type_mismatch);
+    BOOST_TEST(e.categoryCode() == type_mismatch);
   }
   catch (...) {
     BOOST_FAIL("Wrong exception type thrown");
@@ -79,7 +81,7 @@ BOOST_AUTO_TEST_CASE(DoubleStringMismatchNoDefault)
     BOOST_FAIL("Failed to throw an exception as expected");
   }
   catch (fhicl::exception& e) {
-    BOOST_CHECK_EQUAL(e.categoryCode(), type_mismatch);
+    BOOST_TEST(e.categoryCode() == type_mismatch);
   }
   catch (...) {
     BOOST_FAIL("Wrong exception type thrown");
@@ -88,7 +90,7 @@ BOOST_AUTO_TEST_CASE(DoubleStringMismatchNoDefault)
 
 BOOST_AUTO_TEST_CASE(StringSuccess)
 {
-  BOOST_CHECK_EQUAL("rain", pset.get<std::string>("e"));
+  BOOST_TEST("rain" == pset.get<std::string>("e"));
 }
 
 BOOST_AUTO_TEST_CASE(NotFound)
@@ -98,7 +100,7 @@ BOOST_AUTO_TEST_CASE(NotFound)
     BOOST_FAIL("Failed to throw an exception as expected");
   }
   catch (fhicl::exception& e) {
-    BOOST_CHECK_EQUAL(e.categoryCode(), cant_find);
+    BOOST_TEST(e.categoryCode() == cant_find);
   }
   catch (...) {
     BOOST_FAIL("Wrong exception type thrown");
@@ -110,9 +112,9 @@ BOOST_AUTO_TEST_CASE(DeepVector)
   using vv_t = std::vector<std::vector<uint32_t>>;
   vv_t vv;
   BOOST_CHECK_NO_THROW(vv = pset.get<vv_t>("vv"));
-  BOOST_CHECK_EQUAL(vv.front().back(), 3u);
-  BOOST_CHECK_EQUAL(vv.back().front(), 2u);
-  BOOST_CHECK_EQUAL(vv.back().back(), 4u);
+  BOOST_TEST(vv.front().back() == 3u);
+  BOOST_TEST(vv.back().front() == 2u);
+  BOOST_TEST(vv.back().back() == 4u);
 }
 
 BOOST_AUTO_TEST_CASE(is_key_to)
@@ -135,10 +137,10 @@ BOOST_AUTO_TEST_CASE(is_key_to)
   fhicl::ParameterSet ps;
   ps.put("p", p);
 
-  BOOST_CHECK(ps.is_key_to_atom("p.i"));
-  BOOST_CHECK(ps.is_key_to_sequence("p.js"));
-  BOOST_CHECK(ps.is_key_to_atom("p.js[2]"));
-  BOOST_CHECK(ps.is_key_to_table("p.t"));
+  BOOST_TEST(ps.is_key_to_atom("p.i"));
+  BOOST_TEST(ps.is_key_to_sequence("p.js"));
+  BOOST_TEST(ps.is_key_to_atom("p.js[2]"));
+  BOOST_TEST(ps.is_key_to_table("p.t"));
 }
 
 BOOST_AUTO_TEST_CASE(put)
@@ -146,7 +148,7 @@ BOOST_AUTO_TEST_CASE(put)
   std::string const sval = "friendly";
   std::string const sval2 = "unfriendly";
   BOOST_CHECK_NO_THROW(pset.put("putTest", sval));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putTest"), sval);
+  BOOST_TEST(pset.get<std::string>("putTest") == sval);
   BOOST_CHECK_EXCEPTION(
     pset.put("putTest", sval2), fhicl::exception, [](auto const& e) {
       return e.categoryCode() == fhicl::error::cant_insert;
@@ -158,9 +160,9 @@ BOOST_AUTO_TEST_CASE(put_or_replace)
   std::string const sval = "friendly";
   std::string const sval2 = "superfriendly";
   BOOST_CHECK_NO_THROW(pset.put_or_replace("putOrReplaceTest", sval));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putOrReplaceTest"), sval);
+  BOOST_TEST(pset.get<std::string>("putOrReplaceTest") == sval);
   BOOST_CHECK_NO_THROW(pset.put_or_replace("putOrReplaceTest", sval2));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putOrReplaceTest"), sval2);
+  BOOST_TEST(pset.get<std::string>("putOrReplaceTest") == sval2);
 }
 
 BOOST_AUTO_TEST_CASE(put_or_replace_compatible_nil)
@@ -173,22 +175,22 @@ BOOST_AUTO_TEST_CASE(put_or_replace_compatible_nil)
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", sval));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putOrReplaceCompatibleTest"), sval);
+  BOOST_TEST(pset.get<std::string>("putOrReplaceCompatibleTest") == sval);
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval.front()));
-  BOOST_CHECK_EQUAL(pset.get<int>("putOrReplaceCompatibleTest"), vval.front());
+  BOOST_TEST(pset.get<int>("putOrReplaceCompatibleTest") == vval.front());
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval));
-  BOOST_CHECK(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval);
+  BOOST_TEST(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval);
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", psval));
-  BOOST_CHECK(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") == psval);
+  BOOST_TEST(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") == psval);
 }
 
 BOOST_AUTO_TEST_CASE(put_or_replace_compatible_atom)
@@ -201,10 +203,10 @@ BOOST_AUTO_TEST_CASE(put_or_replace_compatible_atom)
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", sval));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putOrReplaceCompatibleTest"), sval);
+  BOOST_TEST(pset.get<std::string>("putOrReplaceCompatibleTest") == sval);
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", sval2));
-  BOOST_CHECK_EQUAL(pset.get<std::string>("putOrReplaceCompatibleTest"), sval2);
+  BOOST_TEST(pset.get<std::string>("putOrReplaceCompatibleTest") == sval2);
   BOOST_CHECK_EXCEPTION(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval),
     fhicl::exception,
@@ -219,7 +221,7 @@ BOOST_AUTO_TEST_CASE(put_or_replace_compatible_atom)
     });
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval.front()));
-  BOOST_CHECK_EQUAL(pset.get<int>("putOrReplaceCompatibleTest"), vval.front());
+  BOOST_TEST(pset.get<int>("putOrReplaceCompatibleTest") == vval.front());
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
 }
@@ -234,10 +236,10 @@ BOOST_AUTO_TEST_CASE(put_or_replace_compatible_sequence)
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval));
-  BOOST_CHECK(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval);
+  BOOST_TEST(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval);
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", vval2));
-  BOOST_CHECK(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval2);
+  BOOST_TEST(pset.get<decltype(vval)>("putOrReplaceCompatibleTest") == vval2);
   BOOST_CHECK_EXCEPTION(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", sval),
     fhicl::exception,
@@ -265,11 +267,10 @@ BOOST_AUTO_TEST_CASE(put_or_replace_compatible_table)
     pset.put_or_replace("putOrReplaceCompatibleTest")); // Nil.
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", psval));
-  BOOST_CHECK(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") == psval);
+  BOOST_TEST(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") == psval);
   BOOST_CHECK_NO_THROW(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", psval2));
-  BOOST_CHECK(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") ==
-              psval2);
+  BOOST_TEST(pset.get<decltype(psval)>("putOrReplaceCompatibleTest") == psval2);
   BOOST_CHECK_EXCEPTION(
     pset.put_or_replace_compatible("putOrReplaceCompatibleTest", sval),
     fhicl::exception,
@@ -336,12 +337,11 @@ hex(std::string const& from)
 
 BOOST_AUTO_TEST_CASE(Custom)
 {
-  BOOST_CHECK_EQUAL(pset.get<std::string>("n"), "0x123");
+  BOOST_TEST(pset.get<std::string>("n") == "0x123");
   unsigned u;
-  BOOST_CHECK(pset.get_if_present("n", u, hex));
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("n", hex), u);
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("n", hex),
-                    (((1u) * 16u + 2u) * 16u + 3u));
+  BOOST_TEST(pset.get_if_present("n", u, hex));
+  BOOST_TEST(pset.get<unsigned>("n", hex) == u);
+  BOOST_TEST(pset.get<unsigned>("n", hex), (((1u) * 16u + 2u) * 16u + 3u));
   BOOST_CHECK_THROW(pset.get_if_present("e", u, hex), std::string);
 }
 
diff --git a/fhiclcpp/test/WriteSQLiteDB_t.cc b/fhiclcpp/test/WriteSQLiteDB_t.cc
index c0615a4..7fdfb63 100644
--- a/fhiclcpp/test/WriteSQLiteDB_t.cc
+++ b/fhiclcpp/test/WriteSQLiteDB_t.cc
@@ -13,10 +13,10 @@ BOOST_AUTO_TEST_CASE(write_sqlite)
   int rc = sqlite3_open_v2(
     "test.db", &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, nullptr);
 
-  BOOST_CHECK_EQUAL(rc, SQLITE_OK);
+  BOOST_TEST(rc == SQLITE_OK);
   fhicl::parse_file_and_fill_db("db_2.fcl", db);
   rc = sqlite3_close(db);
-  BOOST_CHECK_EQUAL(rc, SQLITE_OK);
+  BOOST_TEST(rc == SQLITE_OK);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/boost_test_print_pset.h b/fhiclcpp/test/boost_test_print_pset.h
new file mode 100644
index 0000000..a8e3ce3
--- /dev/null
+++ b/fhiclcpp/test/boost_test_print_pset.h
@@ -0,0 +1,25 @@
+#ifndef fhiclcpp_test_boost_test_print_pset_h
+#define fhiclcpp_test_boost_test_print_pset_h
+
+// ==================================================================
+// The function here is provided so that Boost knows how to form a
+// printout message should a test (e.g. BOOST_TEST(ps1 == ps2)) fail.
+// ==================================================================
+
+#include "fhiclcpp/ParameterSet.h"
+
+#include <ostream>
+
+namespace fhicl {
+  inline std::ostream&
+  boost_test_print_type(std::ostream& os, ParameterSet const& pset)
+  {
+    return os << pset.to_indented_string();
+  }
+}
+
+#endif /* fhiclcpp_test_boost_test_print_pset_h */
+
+// Local Variables:
+// mode: c++
+// End:
diff --git a/fhiclcpp/test/equalTest.cc b/fhiclcpp/test/equalTest.cc
index 560fe35..5e70149 100644
--- a/fhiclcpp/test/equalTest.cc
+++ b/fhiclcpp/test/equalTest.cc
@@ -5,6 +5,7 @@
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
 #include "fhiclcpp/parse.h"
+#include "fhiclcpp/test/boost_test_print_pset.h"
 #include <string>
 
 using namespace fhicl;
@@ -12,22 +13,6 @@ using namespace std;
 
 BOOST_AUTO_TEST_SUITE(document_test)
 
-/*BOOST_AUTO_TEST_CASE( canonical_form )
-{
-  std::string doc1 = "x : .5";
-  std::string doc2 = "x : 0.5";
-  intermediate_table tbl1;
-  intermediate_table tbl2;
-  BOOST_CHECK_NO_THROW( parse_document(doc1, tbl1) );
-  BOOST_CHECK_NO_THROW( parse_document(doc2, tbl2) );
-  ParameterSet pset1;
-  ParameterSet pset2;
-  make_ParameterSet(tbl1, pset1);
-  make_ParameterSet(tbl2, pset2);
-  BOOST_CHECK_EQUAL( pset1.get<int>("x"), pset2.get<int>("x") );
-  BOOST_CHECK_EQUAL( pset1, pset2 );
-}*/
-
 BOOST_AUTO_TEST_CASE(leading_zeros)
 {
   std::string doc1 = "x : 5";
@@ -40,8 +25,8 @@ BOOST_AUTO_TEST_CASE(leading_zeros)
   ParameterSet pset2;
   make_ParameterSet(tbl1, pset1);
   make_ParameterSet(tbl2, pset2);
-  BOOST_CHECK_EQUAL(pset1.get<int>("x"), pset2.get<int>("x"));
-  BOOST_CHECK(pset1 == pset2);
+  BOOST_TEST(pset1.get<int>("x") == pset2.get<int>("x"));
+  BOOST_TEST(pset1 == pset2);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/get_sequence_elements_t.cc b/fhiclcpp/test/get_sequence_elements_t.cc
index d255978..bbb60a3 100644
--- a/fhiclcpp/test/get_sequence_elements_t.cc
+++ b/fhiclcpp/test/get_sequence_elements_t.cc
@@ -1,7 +1,6 @@
 #define BOOST_TEST_MODULE (get sequence elements test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
@@ -34,23 +33,23 @@ BOOST_FIXTURE_TEST_SUITE(sampleConfig, SampleConfigFixture)
 
 BOOST_AUTO_TEST_CASE(element_lookup)
 {
-  BOOST_CHECK_EQUAL(pset.get<int>("g[0]"), 1);
-  BOOST_CHECK_EQUAL(pset.get<int>("h[0].h1"), 12);
-  BOOST_CHECK_EQUAL(pset.get<int>("m[0]"), -1);
-  BOOST_CHECK_EQUAL(pset.get<int>("vv[0][1]"), 2);
+  BOOST_TEST(pset.get<int>("g[0]") == 1);
+  BOOST_TEST(pset.get<int>("h[0].h1") == 12);
+  BOOST_TEST(pset.get<int>("m[0]") == -1);
+  BOOST_TEST(pset.get<int>("vv[0][1]") == 2);
 
-  BOOST_CHECK_EQUAL(pset.get<std::string>("h[1].h2"), "h2");
+  BOOST_TEST(pset.get<std::string>("h[1].h2") == "h2");
 }
 
 BOOST_AUTO_TEST_CASE(element_container_lookup)
 {
-  auto vec0 = pset.get<std::vector<int>>("vv[0]");
-  auto ref0 = {1, 2, 3};
-  CET_CHECK_EQUAL_COLLECTIONS(vec0, ref0);
+  auto const vec0 = pset.get<std::vector<int>>("vv[0]");
+  std::vector const ref0{1, 2, 3};
+  BOOST_TEST(vec0 == ref0);
 
   auto vec1 = pset.get<std::vector<int>>("vv[1]");
-  auto ref1 = {2, 3, 4};
-  CET_CHECK_EQUAL_COLLECTIONS(vec1, ref1);
+  std::vector const ref1{2, 3, 4};
+  BOOST_TEST(vec1 == ref1);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/get_via_t.cc b/fhiclcpp/test/get_via_t.cc
new file mode 100644
index 0000000..b9a4e09
--- /dev/null
+++ b/fhiclcpp/test/get_via_t.cc
@@ -0,0 +1,48 @@
+#define BOOST_TEST_MODULE (get via converter test)
+#include "cetlib/quiet_unit_test.hpp"
+
+#include "cetlib/container_algorithms.h"
+#include "fhiclcpp/ParameterSet.h"
+#include "fhiclcpp/make_ParameterSet.h"
+
+#include <string>
+#include <vector>
+
+using namespace fhicl;
+using namespace std::string_literals;
+
+namespace {
+  struct SortedNames {
+    std::vector<std::string> names;
+  };
+
+  SortedNames
+  to_sorted_names(std::vector<std::string> const& names)
+  {
+    SortedNames result{names};
+    cet::sort_all(result.names);
+    return result;
+  }
+}
+
+BOOST_AUTO_TEST_SUITE(via_test)
+
+BOOST_AUTO_TEST_CASE(via_test)
+{
+  auto const config = "number: 5 "
+                      "names: ['Esther', 'Julian', 'Bobby']"s;
+  ParameterSet pset;
+  make_ParameterSet(config, pset);
+
+  BOOST_TEST(pset.get<int>("number") == 5);
+
+  auto check_value = [](int const& i) { return i == 5; };
+  auto const supplied_5 = pset.get<bool, int>("number", check_value);
+  BOOST_TEST(supplied_5);
+
+  auto const sorted_names = pset.get("names", to_sorted_names);
+  std::vector const ref{"Bobby"s, "Esther"s, "Julian"s};
+  BOOST_TEST(sorted_names.names == ref);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/intermediate_table_t.cc b/fhiclcpp/test/intermediate_table_t.cc
index 02949fd..9894728 100644
--- a/fhiclcpp/test/intermediate_table_t.cc
+++ b/fhiclcpp/test/intermediate_table_t.cc
@@ -29,19 +29,19 @@ BOOST_AUTO_TEST_CASE(main)
   table.put("table.t1.val", "oops");
   BOOST_CHECK_NO_THROW(table.erase("table.t1.waldo"));
   BOOST_CHECK_NO_THROW(table.erase("table.t1.val"));
-  BOOST_CHECK(!table.exists("table.t1.val"));
+  BOOST_TEST(!table.exists("table.t1.val"));
   BOOST_CHECK_THROW(table.erase("table.val1.valX"), fhicl::exception);
-  BOOST_CHECK_EQUAL(table.get<std::string>("string1"), "string");
-  BOOST_CHECK_EQUAL(table.get<std::string>("string2"), "string");
-  BOOST_CHECK_EQUAL(table.get<std::complex<double>>("complex"),
-                    std::complex<double>(-3, -0.5));
-  BOOST_CHECK_EQUAL(table.get<sequence_t const&>("sequence").size(), 7u);
-  //   BOOST_CHECK_EQUAL(table.get<sequence_t &>("sequence").size(), 7u);
-  BOOST_CHECK_EQUAL(table.get<int>("sequence[3]"), 20);
+  BOOST_TEST(table.get<std::string>("string1") == "string");
+  BOOST_TEST(table.get<std::string>("string2") == "string");
+  BOOST_TEST(table.get<std::complex<double>>("complex") ==
+             std::complex<double>(-3, -0.5));
+  BOOST_TEST(table.get<sequence_t const&>("sequence").size() == 7u);
+  //   BOOST_TEST(table.get<sequence_t &>("sequence").size() ==  7u);
+  BOOST_TEST(table.get<int>("sequence[3]") == 20);
   BOOST_CHECK_THROW(table.get<int>("sequence[5]"), fhicl::exception); // Nil
-  BOOST_CHECK_EQUAL(table.get<table_t const&>("table").size(), 2u);
-  BOOST_CHECK_EQUAL(table.get<table_t const&>("table.t1").size(), 0u);
-  //  BOOST_CHECK_EQUAL(table.get<table_t &>("table").size(), 2u);
+  BOOST_TEST(table.get<table_t const&>("table").size() == 2u);
+  BOOST_TEST(table.get<table_t const&>("table.t1").size() == 0u);
+  //  BOOST_TEST(table.get<table_t &>("table").size() ==  2u);
   ParameterSet pset;
   make_ParameterSet(table, pset);
   std::cout << pset.to_indented_string() << std::endl;
@@ -56,8 +56,8 @@ q: { @table::w.x.y })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("q.z"));
-  BOOST_CHECK(!pset.has_key("w"));
+  BOOST_TEST(pset.has_key("q.z"));
+  BOOST_TEST(!pset.has_key("w"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_erase_dotted)
@@ -69,8 +69,8 @@ q: { @table::w.x.y })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("q.z"));
-  BOOST_CHECK(!pset.has_key("w"));
+  BOOST_TEST(pset.has_key("q.z"));
+  BOOST_TEST(!pset.has_key("w"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_nested_partial_dup_nested)
@@ -82,8 +82,8 @@ w: { b: { c: 6 } })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.b"));
-  BOOST_CHECK(!pset.has_key("w.x"));
+  BOOST_TEST(pset.has_key("w.b"));
+  BOOST_TEST(!pset.has_key("w.x"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_nested_partial_dup_dotted)
@@ -95,8 +95,8 @@ w.b.c: 6)";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.b"));
-  BOOST_CHECK(!pset.has_key("w.x"));
+  BOOST_TEST(pset.has_key("w.b"));
+  BOOST_TEST(!pset.has_key("w.x"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_dotted_partial_dup_nested)
@@ -108,8 +108,8 @@ w: { b: { c: 6 } })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.b"));
-  BOOST_CHECK(!pset.has_key("w.x"));
+  BOOST_TEST(pset.has_key("w.b"));
+  BOOST_TEST(!pset.has_key("w.x"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_dotted_partial_dup_dotted)
@@ -121,8 +121,8 @@ w.b.c: 6)";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.b"));
-  BOOST_CHECK(!pset.has_key("w.x"));
+  BOOST_TEST(pset.has_key("w.b"));
+  BOOST_TEST(!pset.has_key("w.x"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_nested_dup_nested)
@@ -134,8 +134,8 @@ w: { x: { c: 6 } })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.x.c"));
-  BOOST_CHECK(!pset.has_key("w.x.y"));
+  BOOST_TEST(pset.has_key("w.x.c"));
+  BOOST_TEST(!pset.has_key("w.x.y"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_nested_dup_dotted)
@@ -147,8 +147,8 @@ w.x.c: 6)";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.x.c"));
-  BOOST_CHECK(!pset.has_key("w.x.y"));
+  BOOST_TEST(pset.has_key("w.x.c"));
+  BOOST_TEST(!pset.has_key("w.x.y"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_dotted_dup_nested)
@@ -160,8 +160,8 @@ w: { x: { c: 6 } })";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.x.c"));
-  BOOST_CHECK(!pset.has_key("w.x.y"));
+  BOOST_TEST(pset.has_key("w.x.c"));
+  BOOST_TEST(!pset.has_key("w.x.y"));
 }
 
 BOOST_AUTO_TEST_CASE(prolog_dotted_dup_dotted)
@@ -173,8 +173,8 @@ w.x.c: 6)";
   ParameterSet pset;
   make_ParameterSet(cfg, pset);
   std::cout << pset.to_indented_string() << std::endl;
-  BOOST_CHECK(pset.has_key("w.x.c"));
-  BOOST_CHECK(!pset.has_key("w.x.y"));
+  BOOST_TEST(pset.has_key("w.x.c"));
+  BOOST_TEST(!pset.has_key("w.x.y"));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/key_assembler_t.cc b/fhiclcpp/test/key_assembler_t.cc
index 0db8751..3002bdd 100644
--- a/fhiclcpp/test/key_assembler_t.cc
+++ b/fhiclcpp/test/key_assembler_t.cc
@@ -1,7 +1,6 @@
 #define BOOST_TEST_MODULE (KeyAssembler test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
@@ -31,7 +30,7 @@ BOOST_AUTO_TEST_CASE(t1)
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
   auto const keys = pset.get_all_keys();
-  std::set<std::string> sorted_keys{keys.begin(), keys.end()};
+  std::set<std::string> const sorted_keys{keys.begin(), keys.end()};
 
   auto const ref = {"p1",
                     "p3",
@@ -47,9 +46,8 @@ BOOST_AUTO_TEST_CASE(t1)
                     "p3.g[0].h1",
                     "p3.g[1]",
                     "p3.g[1].h2"};
-  std::set<std::string> sorted_ref{ref.begin(), ref.end()};
-
-  CET_CHECK_EQUAL_COLLECTIONS(sorted_keys, sorted_ref);
+  std::set<std::string> const sorted_ref{ref.begin(), ref.end()};
+  BOOST_TEST(sorted_keys == sorted_ref);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/parse_document_test.cc b/fhiclcpp/test/parse_document_test.cc
index e8e75a5..5172465 100644
--- a/fhiclcpp/test/parse_document_test.cc
+++ b/fhiclcpp/test/parse_document_test.cc
@@ -11,9 +11,19 @@
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
 #include "fhiclcpp/parse.h"
-#include <iostream>
+
+#include <ostream>
 #include <regex>
 #include <string>
+
+namespace fhicl {
+  std::ostream&
+  boost_test_print_type(std::ostream& os, Protection const protection)
+  {
+    return os << to_string(protection);
+  }
+}
+
 using namespace fhicl;
 using namespace std;
 
@@ -26,7 +36,7 @@ BOOST_AUTO_TEST_CASE(empty_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK(pset.is_empty());
+  BOOST_TEST(pset.is_empty());
 }
 
 BOOST_AUTO_TEST_CASE(nonempty_document)
@@ -37,13 +47,13 @@ BOOST_AUTO_TEST_CASE(nonempty_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK(!pset.is_empty());
-  BOOST_CHECK_EQUAL(pset.get<int>("a"), 1);
-  BOOST_CHECK_EQUAL(pset.get<int>("b"), 2);
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("a"), 1u);
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("b"), 2u);
-  BOOST_CHECK_EQUAL(pset.get<string>("a"), "1");
-  BOOST_CHECK_EQUAL(pset.get<string>("b"), "2");
+  BOOST_TEST(!pset.is_empty());
+  BOOST_TEST(pset.get<int>("a") == 1);
+  BOOST_TEST(pset.get<int>("b") == 2);
+  BOOST_TEST(pset.get<unsigned>("a") == 1u);
+  BOOST_TEST(pset.get<unsigned>("b") == 2u);
+  BOOST_TEST(pset.get<string>("a") == "1");
+  BOOST_TEST(pset.get<string>("b") == "2");
 }
 
 BOOST_AUTO_TEST_CASE(nested_document)
@@ -54,15 +64,15 @@ BOOST_AUTO_TEST_CASE(nested_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK(!pset.is_empty());
+  BOOST_TEST(!pset.is_empty());
   BOOST_REQUIRE_NO_THROW(pset.get<ParameterSet>("x"));
-  BOOST_REQUIRE(!pset.get<ParameterSet>("x").is_empty());
-  BOOST_CHECK_EQUAL(pset.get<int>("x.a"), 1);
-  BOOST_CHECK_EQUAL(pset.get<int>("x.b"), 2);
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("x.a"), 1u);
-  BOOST_CHECK_EQUAL(pset.get<unsigned>("x.b"), 2u);
-  BOOST_CHECK_EQUAL(pset.get<string>("x.a"), "1");
-  BOOST_CHECK_EQUAL(pset.get<string>("x.b"), "2");
+  BOOST_TEST_REQUIRE(!pset.get<ParameterSet>("x").is_empty());
+  BOOST_TEST(pset.get<int>("x.a") == 1);
+  BOOST_TEST(pset.get<int>("x.b") == 2);
+  BOOST_TEST(pset.get<unsigned>("x.a") == 1u);
+  BOOST_TEST(pset.get<unsigned>("x.b") == 2u);
+  BOOST_TEST(pset.get<string>("x.a") == "1");
+  BOOST_TEST(pset.get<string>("x.b") == "2");
 }
 
 BOOST_AUTO_TEST_CASE(badly_nested_document)
@@ -88,10 +98,10 @@ BOOST_AUTO_TEST_CASE(overridden_prolog_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK_EQUAL(pset.get<int>("a"), 2);
+  BOOST_TEST(pset.get<int>("a") == 2);
   BOOST_REQUIRE_NO_THROW(pset.get<ParameterSet>("t"));
-  BOOST_REQUIRE(!pset.get<ParameterSet>("t").is_empty());
-  BOOST_CHECK_EQUAL(pset.get<int>("t.a"), 12);
+  BOOST_TEST_REQUIRE(!pset.get<ParameterSet>("t").is_empty());
+  BOOST_TEST(pset.get<int>("t.a") == 12);
   BOOST_CHECK_THROW(pset.get<int>("t.b"), cet::exception);
 }
 
@@ -108,7 +118,7 @@ BOOST_AUTO_TEST_CASE(contiguous_prolog)
                          "END_PROLOG\n";
   intermediate_table tbl;
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
-  BOOST_CHECK(tbl.exists("c"));
+  BOOST_TEST(tbl.exists("c"));
 }
 
 BOOST_AUTO_TEST_CASE(noncontiguous_prolog)
@@ -139,9 +149,9 @@ BOOST_AUTO_TEST_CASE(overridden_toplevel_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK_EQUAL(pset.get<int>("a"), 6);
-  BOOST_CHECK_EQUAL(pset.get<int>("b"), 5);
-  BOOST_CHECK_EQUAL(pset.get<int>("c"), 4);
+  BOOST_TEST(pset.get<int>("a") == 6);
+  BOOST_TEST(pset.get<int>("b") == 5);
+  BOOST_TEST(pset.get<int>("c") == 4);
 }
 
 BOOST_AUTO_TEST_CASE(overridden_nested_document)
@@ -157,9 +167,9 @@ BOOST_AUTO_TEST_CASE(overridden_nested_document)
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
-  BOOST_CHECK_EQUAL(pset.get<int>("t.a"), 6);
-  BOOST_CHECK_EQUAL(pset.get<int>("t.b"), 5);
-  BOOST_CHECK_EQUAL(pset.get<int>("t.c"), 4);
+  BOOST_TEST(pset.get<int>("t.a") == 6);
+  BOOST_TEST(pset.get<int>("t.b") == 5);
+  BOOST_TEST(pset.get<int>("t.c") == 4);
 }
 
 BOOST_AUTO_TEST_CASE(nil_value)
@@ -181,16 +191,16 @@ BOOST_AUTO_TEST_CASE(nil_value)
   typedef void* nil_t;
   nil_t nil_value = 0;
 
-  BOOST_CHECK_EQUAL(pset.get<nil_t>("a"), nil_value);
-  BOOST_CHECK_EQUAL(pset.get<nil_t>("t.a"), nil_value);
+  BOOST_TEST(pset.get<nil_t>("a") == nil_value);
+  BOOST_TEST(pset.get<nil_t>("t.a") == nil_value);
   BOOST_CHECK_THROW(pset.get<string>("a"), fhicl::exception);
   BOOST_CHECK_THROW(pset.get<string>("t.a"), fhicl::exception);
-  BOOST_CHECK_EQUAL(pset.get<string>("b"), "nil");
-  BOOST_CHECK_EQUAL(pset.get<string>("t.b"), "nil");
-  BOOST_CHECK_EQUAL(pset.get<string>("c"), "@nil");
-  BOOST_CHECK_EQUAL(pset.get<string>("t.c"), "@nil");
-  BOOST_CHECK_EQUAL(pset.get<string>("d"), "nil");
-  BOOST_CHECK_EQUAL(pset.get<string>("t.d"), "nil");
+  BOOST_TEST(pset.get<string>("b") == "nil");
+  BOOST_TEST(pset.get<string>("t.b") == "nil");
+  BOOST_TEST(pset.get<string>("c") == "@nil");
+  BOOST_TEST(pset.get<string>("t.c") == "@nil");
+  BOOST_TEST(pset.get<string>("d") == "nil");
+  BOOST_TEST(pset.get<string>("t.d") == "nil");
 }
 
 BOOST_AUTO_TEST_CASE(erase_value)
@@ -207,15 +217,15 @@ BOOST_AUTO_TEST_CASE(erase_value)
                          "b.x: @erase\n";
   intermediate_table tbl;
   BOOST_REQUIRE_NO_THROW(parse_document(document, tbl));
-  BOOST_CHECK(tbl.exists("x"));
-  BOOST_CHECK(!tbl.exists("z"));
-  BOOST_CHECK(!tbl.exists("a"));
-  BOOST_CHECK(tbl.exists("b"));
-  BOOST_CHECK(!tbl.exists("b.x"));
-  BOOST_CHECK(tbl.exists("b.y"));
-  BOOST_CHECK(tbl.exists("c"));
-  BOOST_CHECK(!tbl.exists("c.x"));
-  BOOST_CHECK(tbl.exists("c.y"));
+  BOOST_TEST(tbl.exists("x"));
+  BOOST_TEST(!tbl.exists("z"));
+  BOOST_TEST(!tbl.exists("a"));
+  BOOST_TEST(tbl.exists("b"));
+  BOOST_TEST(!tbl.exists("b.x"));
+  BOOST_TEST(tbl.exists("b.y"));
+  BOOST_TEST(tbl.exists("c"));
+  BOOST_TEST(!tbl.exists("c.x"));
+  BOOST_TEST(tbl.exists("c.y"));
 }
 
 BOOST_AUTO_TEST_CASE(expand_nested_tables)
@@ -231,7 +241,7 @@ BOOST_AUTO_TEST_CASE(expand_nested_tables)
                          "}\n";
   intermediate_table tbl;
   parse_document(document, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::string>("modules.A.B.x"), std::string("bar"));
+  BOOST_TEST(tbl.get<std::string>("modules.A.B.x") == std::string("bar"));
 }
 
 BOOST_AUTO_TEST_CASE(expand_table)
@@ -245,15 +255,15 @@ BOOST_AUTO_TEST_CASE(expand_table)
                          "y: @local::y\n";
   intermediate_table tbl;
   parse_document(document, tbl);
-  BOOST_CHECK(tbl.exists("x.ethel"));
-  BOOST_CHECK(tbl.exists("x.charlie"));
-  BOOST_CHECK(tbl.exists("bill"));
-  BOOST_CHECK(tbl.exists("charlie"));
-  BOOST_CHECK(tbl.exists("y.bill"));
-  BOOST_CHECK(tbl.exists("y.charlie"));
-  BOOST_CHECK_EQUAL(tbl.get<std::string>("x.bill"), std::string("twelve"));
-  BOOST_CHECK_EQUAL(tbl.get<std::string>("bill"), std::string("twelve"));
-  BOOST_CHECK_EQUAL(tbl.get<std::string>("y.bill"), std::string("one dozen"));
+  BOOST_TEST(tbl.exists("x.ethel"));
+  BOOST_TEST(tbl.exists("x.charlie"));
+  BOOST_TEST(tbl.exists("bill"));
+  BOOST_TEST(tbl.exists("charlie"));
+  BOOST_TEST(tbl.exists("y.bill"));
+  BOOST_TEST(tbl.exists("y.charlie"));
+  BOOST_TEST(tbl.get<std::string>("x.bill") == std::string("twelve"));
+  BOOST_TEST(tbl.get<std::string>("bill") == std::string("twelve"));
+  BOOST_TEST(tbl.get<std::string>("y.bill") == std::string("one dozen"));
 }
 
 BOOST_AUTO_TEST_CASE(expand_sequence)
@@ -266,15 +276,15 @@ BOOST_AUTO_TEST_CASE(expand_sequence)
                          "ethel: [ @sequence::fred, six ]\n";
   intermediate_table tbl;
   parse_document(document, tbl);
-  BOOST_CHECK(tbl.exists("fred"));
-  BOOST_CHECK(tbl.exists("bill"));
-  BOOST_CHECK(tbl.exists("charlie"));
-  BOOST_CHECK(tbl.exists("ethel"));
+  BOOST_TEST(tbl.exists("fred"));
+  BOOST_TEST(tbl.exists("bill"));
+  BOOST_TEST(tbl.exists("charlie"));
+  BOOST_TEST(tbl.exists("ethel"));
 
   ParameterSet pset;
   make_ParameterSet(tbl, pset);
 
-  BOOST_CHECK_EQUAL(pset.get<std::vector<std::string>>("charlie").size(), 3ul);
+  BOOST_TEST(pset.get<std::vector<std::string>>("charlie").size() == 3ul);
 
   std::vector<std::string> const billref{
     "one", "two", "three", "four", "five", "six"};
@@ -282,10 +292,10 @@ BOOST_AUTO_TEST_CASE(expand_sequence)
 
   auto cmp = [](std::vector<std::string> const& seq,
                 std::vector<std::string> const& ref) {
-    BOOST_CHECK_EQUAL(seq.size(), ref.size());
+    BOOST_TEST(seq.size() == ref.size());
     for (auto i = seq.cbegin(), e = seq.cend(), iref = ref.cbegin(); i != e;
          ++i, ++iref) {
-      BOOST_CHECK_EQUAL(*i, *iref);
+      BOOST_TEST(*i == *iref);
     }
   };
 
@@ -340,7 +350,7 @@ BOOST_AUTO_TEST_CASE(colon_spacing)
   for (auto const& ref : refs) {
     BOOST_CHECK_NO_THROW(parse_document(prolog + ref, tbl));
     auto const cpos = ref.find("::");
-    BOOST_REQUIRE(cpos != std::string::npos);
+    BOOST_TEST_REQUIRE(cpos != std::string::npos);
     std::string bad1{ref};
     std::string bad2{ref};
     bad1.insert(cpos, " ");
@@ -357,7 +367,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_01)
                           "x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_02)
@@ -369,7 +379,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_02)
                           "x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 37ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 37ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_03)
@@ -381,7 +391,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_03)
                           "x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 33ul);
 }
 
 #define PV_EXCEPTION                                                           \
@@ -399,7 +409,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_04)
                           "x @protect_ignore: 33\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_05)
@@ -410,7 +420,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_05)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_06)
@@ -420,7 +430,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_06)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_07)
@@ -432,8 +442,8 @@ BOOST_AUTO_TEST_CASE(protect_ignore_07)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 37ul);
-  BOOST_CHECK(tbl.find("a.x").protection == fhicl::Protection::NONE);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 37ul);
+  BOOST_TEST(tbl.find("a.x").protection == fhicl::Protection::NONE);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_08)
@@ -445,7 +455,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_08)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_09)
@@ -454,7 +464,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_09)
                           "a.x @protect_ignore: 33\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_10)
@@ -465,7 +475,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_10)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_11)
@@ -475,7 +485,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_11)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_12)
@@ -487,7 +497,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_12)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 37ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 37ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_13)
@@ -499,7 +509,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_13)
                           "a.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_14)
@@ -508,7 +518,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_14)
                           "a @protect_ignore: { x : 33 }\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_15)
@@ -519,7 +529,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_15)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_16)
@@ -529,7 +539,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_16)
                           "a.b.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_17)
@@ -542,7 +552,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_17)
                           "a.b.x : 41\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 37ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 37ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_18)
@@ -554,7 +564,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_18)
                           "a.b.x : 37\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_19)
@@ -563,7 +573,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_19)
                           "a : { b @protect_ignore: { x : 33 } }\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_20)
@@ -574,7 +584,7 @@ BOOST_AUTO_TEST_CASE(protect_ignore_20)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_ignore_21)
@@ -613,7 +623,7 @@ BOOST_AUTO_TEST_CASE(protect_error_02)
                           "x : 33\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_error_03)
@@ -651,7 +661,7 @@ BOOST_AUTO_TEST_CASE(protect_error_06)
                           "a : { x @protect_error: 33 }\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_error_07)
@@ -662,7 +672,7 @@ BOOST_AUTO_TEST_CASE(protect_error_07)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.x"), 33ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.x") == 33ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_error_08)
@@ -709,7 +719,7 @@ BOOST_AUTO_TEST_CASE(erase_01)
                           "x : @erase";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK(tbl.empty());
+  BOOST_TEST(tbl.empty());
 }
 
 BOOST_AUTO_TEST_CASE(erase_02)
@@ -720,7 +730,7 @@ BOOST_AUTO_TEST_CASE(erase_02)
                           "END_PROLOG\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK(tbl.empty());
+  BOOST_TEST(tbl.empty());
 }
 
 BOOST_AUTO_TEST_CASE(erase_03)
@@ -729,7 +739,7 @@ BOOST_AUTO_TEST_CASE(erase_03)
                           "x : @erase";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(erase_04)
@@ -746,7 +756,7 @@ BOOST_AUTO_TEST_CASE(erase_05)
                           "a : @erase\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK(tbl.empty());
+  BOOST_TEST(tbl.empty());
 }
 
 BOOST_AUTO_TEST_CASE(erase_06)
@@ -755,7 +765,7 @@ BOOST_AUTO_TEST_CASE(erase_06)
                           "a.b : @erase\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(erase_07)
@@ -764,7 +774,7 @@ BOOST_AUTO_TEST_CASE(erase_07)
                           "a.b.x : @erase\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(erase_08)
@@ -773,7 +783,7 @@ BOOST_AUTO_TEST_CASE(erase_08)
                           "a.b.c : @erase\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.c.x"), 29ul);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.c.x") == 29ul);
 }
 
 BOOST_AUTO_TEST_CASE(erase_09)
@@ -798,7 +808,7 @@ BOOST_AUTO_TEST_CASE(erase_11)
                           "a : @erase\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK(tbl.empty());
+  BOOST_TEST(tbl.empty());
 }
 
 BOOST_AUTO_TEST_CASE(protect_local_01)
@@ -807,7 +817,7 @@ BOOST_AUTO_TEST_CASE(protect_local_01)
                           "b: @local::a\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK(tbl.find("b").protection == Protection::PROTECT_IGNORE);
+  BOOST_TEST(tbl.find("b").protection == Protection::PROTECT_IGNORE);
 }
 
 BOOST_AUTO_TEST_CASE(protect_local_02)
@@ -827,7 +837,7 @@ BOOST_AUTO_TEST_CASE(protect_local_03)
                           "b: 43\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("b"), 42ul);
+  BOOST_TEST(tbl.get<std::size_t>("b") == 42ul);
 }
 
 BOOST_AUTO_TEST_CASE(protect_local_04)
@@ -849,8 +859,8 @@ BOOST_AUTO_TEST_CASE(protect_local_05)
                           "a.b.x: 29\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 27ul);
-  BOOST_CHECK(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 27ul);
+  BOOST_TEST(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
 }
 
 BOOST_AUTO_TEST_CASE(protect_local_06)
@@ -875,10 +885,10 @@ BOOST_AUTO_TEST_CASE(protect_local_07)
                           "a.b.x: 29\n";
   intermediate_table tbl;
   parse_document(doc, tbl);
-  BOOST_CHECK_EQUAL(tbl.get<std::size_t>("a.b.x"), 27ul);
-  BOOST_CHECK(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
-  BOOST_CHECK(tbl.find("a").protection == Protection::PROTECT_IGNORE);
-  BOOST_CHECK(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
+  BOOST_TEST(tbl.get<std::size_t>("a.b.x") == 27ul);
+  BOOST_TEST(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
+  BOOST_TEST(tbl.find("a").protection == Protection::PROTECT_IGNORE);
+  BOOST_TEST(tbl.find("a.b.x").protection == Protection::PROTECT_IGNORE);
 }
 
 namespace {
diff --git a/fhiclcpp/test/parse_shimmeddocument_test.cc b/fhiclcpp/test/parse_shimmeddocument_test.cc
index 79bbbdc..3016615 100644
--- a/fhiclcpp/test/parse_shimmeddocument_test.cc
+++ b/fhiclcpp/test/parse_shimmeddocument_test.cc
@@ -27,7 +27,7 @@ using sequence_t = fhicl::extended_value::sequence_t;
  */
 BOOST_AUTO_TEST_CASE(enable_snippet_mode)
 {
-  BOOST_CHECK(::shims::isSnippetMode(true));
+  BOOST_TEST(::shims::isSnippetMode(true));
 }
 
 /*
@@ -35,7 +35,7 @@ BOOST_AUTO_TEST_CASE(enable_snippet_mode)
  */
 BOOST_AUTO_TEST_CASE(can_access_prolog_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " a: 1\n"
@@ -47,22 +47,22 @@ BOOST_AUTO_TEST_CASE(can_access_prolog_01)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
-  BOOST_CHECK(fhicl_table.exists("a"));
+  BOOST_TEST(fhicl_table.exists("a"));
   auto const& a = fhicl_table.find("a");
-  BOOST_CHECK(a.in_prolog == true);
-  BOOST_CHECK(std::any_cast<std::string>(a.value) == "1");
+  BOOST_TEST(a.in_prolog == true);
+  BOOST_TEST(std::any_cast<std::string>(a.value) == "1");
 
-  BOOST_CHECK(fhicl_table.exists("b"));
+  BOOST_TEST(fhicl_table.exists("b"));
   auto const& b = fhicl_table.find("b");
-  BOOST_CHECK(b.in_prolog == true);
-  BOOST_CHECK(std::any_cast<std::string>(b.value) == "\"bb\"");
+  BOOST_TEST(b.in_prolog == true);
+  BOOST_TEST(std::any_cast<std::string>(b.value) == "\"bb\"");
 
-  BOOST_CHECK(fhicl_table.exists("c"));
+  BOOST_TEST(fhicl_table.exists("c"));
   auto const& c = fhicl_table.find("c");
-  BOOST_CHECK(c.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(c.value) == "3");
+  BOOST_TEST(c.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(c.value) == "3");
 }
 
 /*
@@ -71,7 +71,7 @@ BOOST_AUTO_TEST_CASE(can_access_prolog_01)
  */
 BOOST_AUTO_TEST_CASE(preserved_order_of_values_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -82,19 +82,19 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_01)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
 
   auto it = fhicl_table.begin();
 
-  BOOST_CHECK(it->second.in_prolog == true);
-  BOOST_CHECK(it->first == "z");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "1.1");
+  BOOST_TEST(it->second.in_prolog == true);
+  BOOST_TEST(it->first == "z");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "1.1");
 
   std::advance(it, 1);
 
-  BOOST_CHECK(it->second.in_prolog == true);
-  BOOST_CHECK(it->first == "a");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"aa\"");
+  BOOST_TEST(it->second.in_prolog == true);
+  BOOST_TEST(it->first == "a");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"aa\"");
 }
 
 /*
@@ -103,7 +103,7 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_01)
  */
 BOOST_AUTO_TEST_CASE(preserved_order_of_values_02)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "z: 1.1\n"
                          "a: aa\n";
@@ -112,19 +112,19 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_02)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
 
   auto it = fhicl_table.begin();
 
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "z");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "1.1");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "z");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "1.1");
 
   std::advance(it, 1);
 
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "a");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"aa\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "a");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"aa\"");
 }
 
 /*
@@ -133,7 +133,7 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_02)
  */
 BOOST_AUTO_TEST_CASE(preserved_order_of_values_03)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -146,27 +146,27 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_03)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
   auto it = fhicl_table.begin();
-  BOOST_CHECK(it->second.in_prolog == true);
-  BOOST_CHECK(it->first == "z");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "1.1");
+  BOOST_TEST(it->second.in_prolog == true);
+  BOOST_TEST(it->first == "z");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "1.1");
 
   std::advance(it, 1);
-  BOOST_CHECK(it->second.in_prolog == true);
-  BOOST_CHECK(it->first == "a");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"aa\"");
+  BOOST_TEST(it->second.in_prolog == true);
+  BOOST_TEST(it->first == "a");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"aa\"");
 
   std::advance(it, 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "x");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"xx\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "x");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"xx\"");
 
   std::advance(it, 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"cc\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"cc\"");
 }
 
 /*
@@ -175,7 +175,7 @@ BOOST_AUTO_TEST_CASE(preserved_order_of_values_03)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "z: 1.1\n"
                          "ss: {rr: zz}\n"
@@ -185,12 +185,12 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_01)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
-  BOOST_CHECK(fhicl_table.exists("mm"));
+  BOOST_TEST(fhicl_table.exists("mm"));
   auto const& mm = fhicl_table.find("mm");
-  BOOST_CHECK(mm.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
+  BOOST_TEST(mm.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
 }
 
 /*
@@ -199,7 +199,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_01)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_02)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -211,12 +211,12 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_02)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
-  BOOST_CHECK(fhicl_table.exists("mm"));
+  BOOST_TEST(fhicl_table.exists("mm"));
   auto const& mm = fhicl_table.find("mm");
-  BOOST_CHECK(mm.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
+  BOOST_TEST(mm.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
 }
 
 /*
@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_02)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_03)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " tt: { a:1 b: 2 }\n"
@@ -236,13 +236,13 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_03)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(fhicl_table.exists("placeholder_table_001"));
+  BOOST_TEST(fhicl_table.exists("placeholder_table_001"));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
 
   auto const& tt = fhicl_table.find("placeholder_table_001");
-  BOOST_CHECK(tt.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(tt.value) == "\"@table::tt\"");
+  BOOST_TEST(tt.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(tt.value) == "\"@table::tt\"");
 }
 
 /*
@@ -251,7 +251,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_03)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_04)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " tt: { a:1 b: 2 }\n"
@@ -262,13 +262,13 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_04)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 2);
 
-  BOOST_CHECK(fhicl_table.exists("placeholder_table_001"));
+  BOOST_TEST(fhicl_table.exists("placeholder_table_001"));
 
   auto const& tt = fhicl_table.find("placeholder_table_001");
-  BOOST_CHECK(tt.in_prolog == true);
-  BOOST_CHECK(std::any_cast<std::string>(tt.value) == "\"@table::tt\"");
+  BOOST_TEST(tt.in_prolog == true);
+  BOOST_TEST(std::any_cast<std::string>(tt.value) == "\"@table::tt\"");
 }
 
 /*
@@ -277,7 +277,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_04)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_05)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -289,13 +289,13 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_05)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
   auto const& sss = fhicl_table.find("sss");
-  BOOST_CHECK(sss.in_prolog == false);
+  BOOST_TEST(sss.in_prolog == false);
   sequence_t seq = sss;
-  BOOST_CHECK(std::any_cast<std::string>(seq.at(0).value) ==
-              "\"@sequence::ss\"");
+  BOOST_TEST(std::any_cast<std::string>(seq.at(0).value) ==
+             "\"@sequence::ss\"");
 }
 
 /*
@@ -304,7 +304,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_05)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_06)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -315,13 +315,13 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_06)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
   auto const& sss = fhicl_table.find("sss");
-  BOOST_CHECK(sss.in_prolog == true);
+  BOOST_TEST(sss.in_prolog == true);
   sequence_t seq = sss;
-  BOOST_CHECK(std::any_cast<std::string>(seq.at(0).value) ==
-              "\"@sequence::ss\"");
+  BOOST_TEST(std::any_cast<std::string>(seq.at(0).value) ==
+             "\"@sequence::ss\"");
 }
 
 /*
@@ -329,7 +329,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_06)
  */
 BOOST_AUTO_TEST_CASE(keep_unresolved_references_07)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -341,19 +341,19 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_07)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
-  BOOST_CHECK(fhicl_table.exists("mm"));
+  BOOST_TEST(fhicl_table.exists("mm"));
 
   auto const& mm = fhicl_table.find("mm");
-  BOOST_CHECK(mm.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
+  BOOST_TEST(mm.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(mm.value) == "\"@local::ss\"");
 
   auto it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "mm");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"@erase\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "mm");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"@erase\"");
 }
 
 /*
@@ -362,7 +362,7 @@ BOOST_AUTO_TEST_CASE(keep_unresolved_references_07)
  */
 BOOST_AUTO_TEST_CASE(keep_nil_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " a: @nil\n"
@@ -374,16 +374,16 @@ BOOST_AUTO_TEST_CASE(keep_nil_01)
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
 
-  BOOST_CHECK(fhicl_table.exists("mm"));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(fhicl_table.exists("mm"));
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
   auto const& mm = fhicl_table.find("mm");
-  BOOST_CHECK(mm.in_prolog == false);
-  BOOST_CHECK(mm.is_a(::fhicl::NIL));
+  BOOST_TEST(mm.in_prolog == false);
+  BOOST_TEST(mm.is_a(::fhicl::NIL));
 
   auto const& a = fhicl_table.find("a");
-  BOOST_CHECK(a.in_prolog == true);
-  BOOST_CHECK(a.is_a(::fhicl::NIL));
+  BOOST_TEST(a.in_prolog == true);
+  BOOST_TEST(a.is_a(::fhicl::NIL));
 }
 
 /*
@@ -391,7 +391,7 @@ BOOST_AUTO_TEST_CASE(keep_nil_01)
  */
 BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -403,13 +403,13 @@ BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_01)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 3);
 
-  BOOST_CHECK(fhicl_table.exists("h.hh.hhh"));
+  BOOST_TEST(fhicl_table.exists("h.hh.hhh"));
 
   auto const& h = fhicl_table.find("h.hh.hhh");
-  BOOST_CHECK(h.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(h.value) == "\"h\"");
+  BOOST_TEST(h.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(h.value) == "\"h\"");
 }
 
 /*
@@ -417,7 +417,7 @@ BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_01)
  */
 BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_02)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "BEGIN_PROLOG\n"
                          " z: 1.1\n"
@@ -429,25 +429,25 @@ BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_02)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
-  BOOST_CHECK(fhicl_table.exists("c"));
+  BOOST_TEST(fhicl_table.exists("c"));
 
   auto const& c = fhicl_table.find("c");
-  BOOST_CHECK(c.in_prolog == true);
-  BOOST_CHECK(std::any_cast<std::string>(c.value) == "\"c1\"");
+  BOOST_TEST(c.in_prolog == true);
+  BOOST_TEST(std::any_cast<std::string>(c.value) == "\"c1\"");
 
   auto it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 2);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "h.hh.hhh");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"h\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "h.hh.hhh");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"h\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c.cc.ccc");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"@local::c\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c.cc.ccc");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"@local::c\"");
 }
 
 /*
@@ -455,7 +455,7 @@ BOOST_AUTO_TEST_CASE(keep_dots_in_keynames_02)
  */
 BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_01)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "c:c1\n"
                          "c:c2\n"
@@ -465,31 +465,31 @@ BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_01)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
-  BOOST_CHECK(fhicl_table.exists("c"));
+  BOOST_TEST(fhicl_table.exists("c"));
 
   auto const& c = fhicl_table.find("c");
-  BOOST_CHECK(c.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(c.value) == "\"c1\"");
+  BOOST_TEST(c.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(c.value) == "\"c1\"");
 
   auto it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 3);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"c2\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"c2\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 2);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "h");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"h1\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "h");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"h1\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"c3\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"c3\"");
 }
 
 /*
@@ -497,7 +497,7 @@ BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_01)
  */
 BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_02)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "c.cc:c1\n"
                          "c.cc:c2\n"
@@ -507,31 +507,31 @@ BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_02)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
-  BOOST_CHECK(fhicl_table.exists("c.cc"));
+  BOOST_TEST(fhicl_table.exists("c.cc"));
 
   auto const& c = fhicl_table.find("c.cc");
-  BOOST_CHECK(c.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(c.value) == "\"c1\"");
+  BOOST_TEST(c.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(c.value) == "\"c1\"");
 
   auto it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 3);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c.cc");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"c2\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c.cc");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"c2\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 2);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "h");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"h1\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "h");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"h1\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c.cc");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"c3\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c.cc");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"c3\"");
 }
 
 /*
@@ -539,7 +539,7 @@ BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_02)
  */
 BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_03)
 {
-  BOOST_CHECK(::shims::isSnippetMode());
+  BOOST_TEST(::shims::isSnippetMode());
 
   std::string document = "c.cc:c1\n"
                          "c.cc:c2\n"
@@ -549,31 +549,31 @@ BOOST_AUTO_TEST_CASE(allow_duplicate_kvp_03)
   ::fhicl::intermediate_table fhicl_table;
 
   BOOST_REQUIRE_NO_THROW(::fhicl::parse_document(document, fhicl_table));
-  BOOST_CHECK(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
+  BOOST_TEST(std::distance(fhicl_table.begin(), fhicl_table.end()) == 4);
 
-  BOOST_CHECK(fhicl_table.exists("c.cc"));
+  BOOST_TEST(fhicl_table.exists("c.cc"));
 
   auto const& c = fhicl_table.find("c.cc");
-  BOOST_CHECK(c.in_prolog == false);
-  BOOST_CHECK(std::any_cast<std::string>(c.value) == "\"c1\"");
+  BOOST_TEST(c.in_prolog == false);
+  BOOST_TEST(std::any_cast<std::string>(c.value) == "\"c1\"");
 
   auto it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 3);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c.cc");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"c2\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c.cc");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"c2\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 2);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "h");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"h1\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "h");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"h1\"");
 
   it = fhicl_table.begin();
   std::advance(it, std::distance(fhicl_table.begin(), fhicl_table.end()) - 1);
-  BOOST_CHECK(it->second.in_prolog == false);
-  BOOST_CHECK(it->first == "c.cc");
-  BOOST_CHECK(std::any_cast<std::string>(it->second.value) == "\"@local::h\"");
+  BOOST_TEST(it->second.in_prolog == false);
+  BOOST_TEST(it->first == "c.cc");
+  BOOST_TEST(std::any_cast<std::string>(it->second.value) == "\"@local::h\"");
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/table_t_iterator_t.cc b/fhiclcpp/test/table_t_iterator_t.cc
index 91e631a..1f835d0 100644
--- a/fhiclcpp/test/table_t_iterator_t.cc
+++ b/fhiclcpp/test/table_t_iterator_t.cc
@@ -11,33 +11,35 @@
 #include <vector>
 
 using namespace fhicl;
+using table_t = fhicl::extended_value::table_t;
+
+BOOST_TEST_DONT_PRINT_LOG_VALUE(table_t::const_iterator)
+BOOST_TEST_DONT_PRINT_LOG_VALUE(table_t::iterator)
 
 BOOST_AUTO_TEST_SUITE(table_t_iterator_t)
 
 BOOST_AUTO_TEST_CASE(iterator_comparisons_1)
 {
-  BOOST_CHECK(::shims::isSnippetMode(SNIPPET_MODE) == SNIPPET_MODE);
-
-  using table_t = fhicl::extended_value::table_t;
+  BOOST_TEST(::shims::isSnippetMode(SNIPPET_MODE) == SNIPPET_MODE);
 
   table_t table;
   table_t const& ctable = table;
-  BOOST_CHECK(table.cbegin() == table.cend());
-  BOOST_CHECK(table.cbegin() == table.end());
-  BOOST_CHECK(table.begin() == table.end());
-  BOOST_CHECK(table.begin() == table.cend());
-  BOOST_CHECK(ctable.begin() == ctable.end());
-  BOOST_CHECK(table.begin() == table.end());
-  BOOST_CHECK(ctable.begin() == table.end());
-  BOOST_CHECK(table.begin() == ctable.end());
+  BOOST_TEST(table.cbegin() == table.cend());
+  BOOST_TEST(table.cbegin() == table.end());
+  BOOST_TEST(table.begin() == table.end());
+  BOOST_TEST(table.begin() == table.cend());
+  BOOST_TEST(ctable.begin() == ctable.end());
+  BOOST_TEST(table.begin() == table.end());
+  BOOST_TEST(ctable.begin() == table.end());
+  BOOST_TEST(table.begin() == ctable.end());
   table.emplace("string1", extended_value{false, STRING, "string"});
-  BOOST_CHECK(table.cbegin() != table.cend());
-  BOOST_CHECK(table.cbegin() != table.end());
-  BOOST_CHECK(table.begin() != table.end());
-  BOOST_CHECK(table.begin() != table.cend());
-  BOOST_CHECK(ctable.begin() != ctable.end());
-  BOOST_CHECK(table.begin() != table.end());
-  BOOST_CHECK(ctable.begin() != table.end());
-  BOOST_CHECK(table.begin() != ctable.end());
+  BOOST_TEST(table.cbegin() != table.cend());
+  BOOST_TEST(table.cbegin() != table.end());
+  BOOST_TEST(table.begin() != table.end());
+  BOOST_TEST(table.begin() != table.cend());
+  BOOST_TEST(ctable.begin() != ctable.end());
+  BOOST_TEST(table.begin() != table.end());
+  BOOST_TEST(ctable.begin() != table.end());
+  BOOST_TEST(table.begin() != ctable.end());
 }
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/test_suite.cc b/fhiclcpp/test/test_suite.cc
index 1fe2911..20d82ef 100644
--- a/fhiclcpp/test/test_suite.cc
+++ b/fhiclcpp/test/test_suite.cc
@@ -6,6 +6,8 @@
 #include "fhiclcpp/intermediate_table.h"
 #include "fhiclcpp/make_ParameterSet.h"
 #include "fhiclcpp/parse.h"
+#include "fhiclcpp/test/boost_test_print_pset.h"
+
 #include <fstream>
 #include <iostream>
 #include <sstream>
@@ -47,7 +49,7 @@ BOOST_AUTO_TEST_CASE(doc)
     make_ParameterSet(table, ps2);
   }
 
-  BOOST_CHECK(ps1 == ps2);
+  BOOST_TEST(ps1 == ps2);
 
   // Alternative representation.
   ParameterSet ps3;
@@ -59,7 +61,7 @@ BOOST_AUTO_TEST_CASE(doc)
     make_ParameterSet(table, ps3);
   }
 
-  BOOST_CHECK(ps1 == ps3);
+  BOOST_TEST(ps1 == ps3);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/to_indented_string_test.cc b/fhiclcpp/test/to_indented_string_test.cc
index d78e95b..aa38c88 100644
--- a/fhiclcpp/test/to_indented_string_test.cc
+++ b/fhiclcpp/test/to_indented_string_test.cc
@@ -24,22 +24,20 @@ BOOST_AUTO_TEST_SUITE(values_test)
 BOOST_AUTO_TEST_CASE(atoms)
 {
   ParameterSet pset;
-  BOOST_CHECK(pset.is_empty());
-  BOOST_CHECK_EQUAL(to_ind_str(pset), "");
+  BOOST_TEST(pset.is_empty());
+  BOOST_TEST(to_ind_str(pset) == "");
 
   pset.put<std::string>("a", "string1");
-  BOOST_CHECK_EQUAL(to_ind_str(pset), "a: \"string1\"\n");
+  BOOST_TEST(to_ind_str(pset) == "a: \"string1\"\n");
 
   pset.put<int>("b", -1234);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "a: \"string1\"\n"
-                    "b: -1234\n");
+  BOOST_TEST(to_ind_str(pset) == "a: \"string1\"\n"
+                                 "b: -1234\n");
 
   pset.put<bool>("c", false);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "a: \"string1\"\n"
-                    "b: -1234\n"
-                    "c: false\n");
+  BOOST_TEST(to_ind_str(pset) == "a: \"string1\"\n"
+                                 "b: -1234\n"
+                                 "c: false\n");
 }
 
 BOOST_AUTO_TEST_CASE(sequences)
@@ -48,29 +46,27 @@ BOOST_AUTO_TEST_CASE(sequences)
   intv v;
   ParameterSet pset;
   pset.put<intv>("a", v);
-  BOOST_CHECK_EQUAL(to_ind_str(pset), "a: []\n");
+  BOOST_TEST(to_ind_str(pset) == "a: []\n");
 
   v.push_back(11);
   pset.put<intv>("b", v);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "a: []\n"
-                    "b: [\n"
-                    "   11\n"
-                    "]\n");
+  BOOST_TEST(to_ind_str(pset) == "a: []\n"
+                                 "b: [\n"
+                                 "   11\n"
+                                 "]\n");
 
   v.push_back(12);
   v.push_back(13);
   pset.put<intv>("c", v);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "a: []\n"
-                    "b: [\n"
-                    "   11\n"
-                    "]\n"
-                    "c: [\n"
-                    "   11,\n"
-                    "   12,\n"
-                    "   13\n"
-                    "]\n");
+  BOOST_TEST(to_ind_str(pset) == "a: []\n"
+                                 "b: [\n"
+                                 "   11\n"
+                                 "]\n"
+                                 "c: [\n"
+                                 "   11,\n"
+                                 "   12,\n"
+                                 "   13\n"
+                                 "]\n");
 }
 
 BOOST_AUTO_TEST_CASE(tables)
@@ -79,44 +75,41 @@ BOOST_AUTO_TEST_CASE(tables)
 
   ParameterSet p;
   pset.put<ParameterSet>("p1", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset), "p1: {}\n");
+  BOOST_TEST(to_ind_str(pset) == "p1: {}\n");
 
   p.put<std::string>("a", "string1");
   pset.put<ParameterSet>("p2", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p1: {}\n"
-                    "p2: {\n"
-                    "   a: \"string1\"\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p1: {}\n"
+                                 "p2: {\n"
+                                 "   a: \"string1\"\n"
+                                 "}\n");
 
   p.put<int>("b", -1234);
   pset.put<ParameterSet>("p3", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p1: {}\n"
-                    "p2: {\n"
-                    "   a: \"string1\"\n"
-                    "}\n"
-                    "p3: {\n"
-                    "   a: \"string1\"\n"
-                    "   b: -1234\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p1: {}\n"
+                                 "p2: {\n"
+                                 "   a: \"string1\"\n"
+                                 "}\n"
+                                 "p3: {\n"
+                                 "   a: \"string1\"\n"
+                                 "   b: -1234\n"
+                                 "}\n");
 
   p.put<bool>("c", false);
   pset.put<ParameterSet>("p4", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p1: {}\n"
-                    "p2: {\n"
-                    "   a: \"string1\"\n"
-                    "}\n"
-                    "p3: {\n"
-                    "   a: \"string1\"\n"
-                    "   b: -1234\n"
-                    "}\n"
-                    "p4: {\n"
-                    "   a: \"string1\"\n"
-                    "   b: -1234\n"
-                    "   c: false\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p1: {}\n"
+                                 "p2: {\n"
+                                 "   a: \"string1\"\n"
+                                 "}\n"
+                                 "p3: {\n"
+                                 "   a: \"string1\"\n"
+                                 "   b: -1234\n"
+                                 "}\n"
+                                 "p4: {\n"
+                                 "   a: \"string1\"\n"
+                                 "   b: -1234\n"
+                                 "   c: false\n"
+                                 "}\n");
 }
 
 BOOST_AUTO_TEST_CASE(combo)
@@ -132,14 +125,13 @@ BOOST_AUTO_TEST_CASE(combo)
 
   ParameterSet pset;
   pset.put<ParameterSet>("p", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p: {\n"
-                    "   v: [\n"
-                    "      11,\n"
-                    "      12,\n"
-                    "      13\n"
-                    "   ]\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p: {\n"
+                                 "   v: [\n"
+                                 "      11,\n"
+                                 "      12,\n"
+                                 "      13\n"
+                                 "   ]\n"
+                                 "}\n");
 }
 
 BOOST_AUTO_TEST_CASE(sequence_printout)
@@ -153,31 +145,30 @@ BOOST_AUTO_TEST_CASE(sequence_printout)
 
   ParameterSet pset;
   pset.put<ParameterSet>("p", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p: {\n"
-                    "   v: [\n"
-                    "      1,\n"
-                    "      2,\n"
-                    "      3,\n"
-                    "      4,\n"
-                    "      5,\n"
-                    "      6,\n"
-                    "      7,\n"
-                    "      8,\n"
-                    "      9,\n"
-                    "      10,\n"
-                    "      11,\n"
-                    "      12,\n"
-                    "      13,\n"
-                    "      14,\n"
-                    "      15,\n"
-                    "      16,\n"
-                    "      17,\n"
-                    "      18,\n"
-                    "      19,\n"
-                    "      20\n"
-                    "   ]\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p: {\n"
+                                 "   v: [\n"
+                                 "      1,\n"
+                                 "      2,\n"
+                                 "      3,\n"
+                                 "      4,\n"
+                                 "      5,\n"
+                                 "      6,\n"
+                                 "      7,\n"
+                                 "      8,\n"
+                                 "      9,\n"
+                                 "      10,\n"
+                                 "      11,\n"
+                                 "      12,\n"
+                                 "      13,\n"
+                                 "      14,\n"
+                                 "      15,\n"
+                                 "      16,\n"
+                                 "      17,\n"
+                                 "      18,\n"
+                                 "      19,\n"
+                                 "      20\n"
+                                 "   ]\n"
+                                 "}\n");
 }
 
 BOOST_AUTO_TEST_CASE(nested_sequence_printout_empty)
@@ -190,10 +181,9 @@ BOOST_AUTO_TEST_CASE(nested_sequence_printout_empty)
 
   ParameterSet pset;
   pset.put<ParameterSet>("p", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p: {\n"
-                    "   empty: []\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p: {\n"
+                                 "   empty: []\n"
+                                 "}\n");
 }
 
 BOOST_AUTO_TEST_CASE(nested_sequence_printout)
@@ -211,23 +201,22 @@ BOOST_AUTO_TEST_CASE(nested_sequence_printout)
 
   ParameterSet pset;
   pset.put<ParameterSet>("p", p);
-  BOOST_CHECK_EQUAL(to_ind_str(pset),
-                    "p: {\n"
-                    "   nested: [\n"
-                    "      [\n"
-                    "         1,\n"
-                    "         2,\n"
-                    "         3,\n"
-                    "         4\n"
-                    "      ],\n"
-                    "      [\n"
-                    "         1,\n"
-                    "         2,\n"
-                    "         3,\n"
-                    "         4,\n"
-                    "         5\n"
-                    "      ]\n"
-                    "   ]\n"
-                    "}\n");
+  BOOST_TEST(to_ind_str(pset) == "p: {\n"
+                                 "   nested: [\n"
+                                 "      [\n"
+                                 "         1,\n"
+                                 "         2,\n"
+                                 "         3,\n"
+                                 "         4\n"
+                                 "      ],\n"
+                                 "      [\n"
+                                 "         1,\n"
+                                 "         2,\n"
+                                 "         3,\n"
+                                 "         4,\n"
+                                 "         5\n"
+                                 "      ]\n"
+                                 "   ]\n"
+                                 "}\n");
 }
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/bounded_sequences_with_defaults_t.cc b/fhiclcpp/test/types/bounded_sequences_with_defaults_t.cc
index d26aa54..f01fe3a 100644
--- a/fhiclcpp/test/types/bounded_sequences_with_defaults_t.cc
+++ b/fhiclcpp/test/types/bounded_sequences_with_defaults_t.cc
@@ -1,7 +1,6 @@
 #define BOOST_TEST_MODULE (Bounded sequences with defaults)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
 
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/intermediate_table.h"
@@ -47,16 +46,16 @@ BOOST_AUTO_TEST_CASE(GoodArray)
 {
   string const good{};
   auto const& validatedTable = validateConfig<ArrayConfig>(good);
-  BOOST_CHECK_EQUAL(validatedTable().composers(0), "Mahler"s);
-  BOOST_CHECK_EQUAL(validatedTable().composers(1), "Elgar"s);
+  BOOST_TEST(validatedTable().composers(0) == "Mahler"s);
+  BOOST_TEST(validatedTable().composers(1) == "Elgar"s);
 }
 
 BOOST_AUTO_TEST_CASE(GoodTuple)
 {
   string const good{};
   auto const& validatedTable = validateConfig<TupleConfig>(good);
-  BOOST_CHECK_EQUAL(validatedTable().ages.get<0>(), "David"s);
-  BOOST_CHECK_EQUAL(validatedTable().ages.get<1>(), 9u);
+  BOOST_TEST(validatedTable().ages.get<0>() == "David"s);
+  BOOST_TEST(validatedTable().ages.get<1>() == 9u);
 }
 
 BOOST_AUTO_TEST_CASE(BadSequence)
diff --git a/fhiclcpp/test/types/conditional_t.cc b/fhiclcpp/test/types/conditional_t.cc
index 02896ef..0210109 100644
--- a/fhiclcpp/test/types/conditional_t.cc
+++ b/fhiclcpp/test/types/conditional_t.cc
@@ -1,7 +1,6 @@
 #define BOOST_TEST_MODULE (keymap test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/make_ParameterSet.h"
 #include "fhiclcpp/test/types/CondConfig.h"
@@ -45,10 +44,10 @@ BOOST_AUTO_TEST_CASE(cond_02_t)
   Table<CondConfig> table{Name("pset")};
   table.validate_ParameterSet(
     create_PSet(file).get<fhicl::ParameterSet>("pset"));
-  BOOST_CHECK_EQUAL(table().flag(), false);
-  BOOST_CHECK_EQUAL(table().num2(), 4);
-  BOOST_CHECK_EQUAL(table().shape(), "sphere");
-  BOOST_CHECK_EQUAL(table().sphereParams().radius(), 7);
+  BOOST_TEST(table().flag() == false);
+  BOOST_TEST(table().num2() == 4);
+  BOOST_TEST(table().shape() == "sphere");
+  BOOST_TEST(table().sphereParams().radius() == 7);
 }
 
 BOOST_AUTO_TEST_CASE(cond_03_t)
@@ -57,17 +56,17 @@ BOOST_AUTO_TEST_CASE(cond_03_t)
   Table<CondConfig> table{Name("pset")};
   table.validate_ParameterSet(
     create_PSet(file).get<fhicl::ParameterSet>("pset"));
-  BOOST_CHECK_EQUAL(table().flag(), true);
+  BOOST_TEST(table().flag() == true);
   int number{16};
-  BOOST_CHECK_EQUAL(table().num1(number), false);
-  BOOST_CHECK_EQUAL(table().shape(), "box");
+  BOOST_TEST(table().num1(number) == false);
+  BOOST_TEST(table().shape() == "box");
   auto ref = {4, 9, 2};
   auto hls = table().boxParams().halfLengths();
-  CET_CHECK_EQUAL_COLLECTIONS(hls(), ref);
-  BOOST_CHECK_EQUAL(table().boxParams().material(), "Wood");
+  BOOST_TEST(hls() == ref, boost::test_tools::per_element{});
+  BOOST_TEST(table().boxParams().material() == "Wood");
   std::string name;
-  BOOST_CHECK_EQUAL(table().boxParams().boxName(name), true);
-  BOOST_CHECK_EQUAL(name, "Stan");
+  BOOST_TEST(table().boxParams().boxName(name) == true);
+  BOOST_TEST(name == "Stan");
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/delegatedParameter_t.cc b/fhiclcpp/test/types/delegatedParameter_t.cc
index bc1983f..d154ed8 100644
--- a/fhiclcpp/test/types/delegatedParameter_t.cc
+++ b/fhiclcpp/test/types/delegatedParameter_t.cc
@@ -1,7 +1,7 @@
 #define BOOST_TEST_MODULE (delegatedParameter test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
+
 #include "fhiclcpp/test/types/FixtureBase.h"
 #include "fhiclcpp/types/DelegatedParameter.h"
 #include "fhiclcpp/types/OptionalDelegatedParameter.h"
@@ -33,20 +33,20 @@ namespace {
     std::set<std::string> const ref{
       "everything", "everything[0]", "you", "imagine"};
     auto const& test = pset.get_all_keys();
-    CET_CHECK_EQUAL_COLLECTIONS(test, ref);
+    BOOST_TEST(test == ref, boost::test_tools::per_element{});
   }
 
   void
   receive_vector(std::vector<int> const& v)
   {
-    auto const ref = {1, 2, 3};
-    CET_CHECK_EQUAL_COLLECTIONS(v, ref);
+    std::vector const ref{1, 2, 3};
+    BOOST_TEST(v == ref);
   }
 
   void
   receive_int(int const i)
   {
-    BOOST_CHECK_EQUAL(i, 3);
+    BOOST_TEST(i == 3);
   }
 }
 
@@ -59,7 +59,7 @@ BOOST_AUTO_TEST_CASE(delegation_check)
   receive_int(config().nested().da.get<int>());
   std::string maybe_string;
   config().nested().oda.get_if_present(maybe_string);
-  BOOST_CHECK_EQUAL("Hello, Billy"s, maybe_string);
+  BOOST_TEST("Hello, Billy"s == maybe_string);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/keymap_defaults_t.cc b/fhiclcpp/test/types/keymap_defaults_t.cc
index ba2cb09..94dadb6 100644
--- a/fhiclcpp/test/types/keymap_defaults_t.cc
+++ b/fhiclcpp/test/types/keymap_defaults_t.cc
@@ -12,7 +12,6 @@
 
 #include "cetlib/quiet_unit_test.hpp"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/test/types/KeyMap.h"
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
@@ -37,7 +36,7 @@ BOOST_AUTO_TEST_CASE(one_atom_t)
 
   auto map = km.result();
   auto ref = {"atom"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [2] Sequence<T>
@@ -49,7 +48,7 @@ BOOST_AUTO_TEST_CASE(one_sequence_t)
 
   auto map = km.result();
   auto ref = {"sequence", "sequence[0]", "sequence[1]", "sequence[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [3] Sequence<T,SZ>
@@ -61,7 +60,7 @@ BOOST_AUTO_TEST_CASE(one_sequence_2_t)
 
   auto map = km.result();
   auto ref = {"sequence", "sequence[0]", "sequence[1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [4] Tuple<T...>
@@ -73,7 +72,7 @@ BOOST_AUTO_TEST_CASE(one_tuple_t)
 
   auto map = km.result();
   auto ref = {"tuple", "tuple[0]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [5] Tuple< Sequence<T>, U...>
@@ -92,7 +91,7 @@ BOOST_AUTO_TEST_CASE(seq_in_tuple_t)
               "tuple[0][2]",
               "tuple[1]",
               "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [6] Tuple< Sequence<T,SZ>, U...>
@@ -106,7 +105,7 @@ BOOST_AUTO_TEST_CASE(bounded_seq_in_tuple_t)
   auto map = km.result();
   auto ref = {
     "tuple", "tuple[0]", "tuple[0][0]", "tuple[0][1]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [7] Tuple< Tuple<T...>, U...>
@@ -120,7 +119,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_tuple_t)
   auto map = km.result();
   auto ref = {
     "tuple", "tuple[0]", "tuple[0][0]", "tuple[0][1]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [8] Sequence< Tuple<T...> >
@@ -142,7 +141,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_t)
               "seqtuple[2]",
               "seqtuple[2][0]",
               "seqtuple[2][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [9] Sequence< Tuple<T...>, SZ >
@@ -160,7 +159,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_2_t)
               "seqtuple[1]",
               "seqtuple[1][0]",
               "seqtuple[1][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [10] Sequence< Sequence<T> >
@@ -178,7 +177,7 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_t)
               "seqseq[0][2]",
               "seqseq[1]",
               "seqseq[1][0]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [11] Sequence< Sequence<T,SZ> >
@@ -190,7 +189,7 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_t)
 
   auto map = km.result();
   auto ref = {"seqseq", "seqseq[0]", "seqseq[0][0]", "seqseq[0][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [12] Sequence< Sequence<T>, SZ >
@@ -209,7 +208,7 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_2_t)
               "seqseq[1][1]",
               "seqseq[1][2]",
               "seqseq[1][3]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [13] Sequence< Sequence<T,SZ>, SZ >
@@ -227,6 +226,6 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_2_t)
               "seqseq[1]",
               "seqseq[1][0]",
               "seqseq[1][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/keymap_t.cc b/fhiclcpp/test/types/keymap_t.cc
index 7be6c3f..241441a 100644
--- a/fhiclcpp/test/types/keymap_t.cc
+++ b/fhiclcpp/test/types/keymap_t.cc
@@ -9,13 +9,11 @@
 
 #include "cetlib/quiet_unit_test.hpp"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/test/types/KeyMap.h"
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
 #include "fhiclcpp/types/Tuple.h"
 
-#include <iostream>
 #include <string>
 #include <vector>
 
@@ -30,7 +28,7 @@ BOOST_AUTO_TEST_CASE(one_atom_t)
 {
   auto map = KeyMap::get<Atom<int>>("atom");
   auto ref = {"atom"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [2] Sequence<T>
@@ -38,7 +36,7 @@ BOOST_AUTO_TEST_CASE(one_sequence_t)
 {
   auto map = KeyMap::get<Sequence<int>>("sequence");
   auto ref = {"sequence", "sequence[0]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [3] Sequence<T,SZ>
@@ -46,7 +44,7 @@ BOOST_AUTO_TEST_CASE(one_sequence_2_t)
 {
   auto map = KeyMap::get<Sequence<int, 2>>("sequence");
   auto ref = {"sequence", "sequence[0]", "sequence[1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [4] Tuple<T...>
@@ -54,7 +52,7 @@ BOOST_AUTO_TEST_CASE(one_tuple_t)
 {
   auto map = KeyMap::get<Tuple<int, double, bool>>("tuple");
   auto ref = {"tuple", "tuple[0]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [5] Tuple< Sequence<T>, U...>
@@ -62,7 +60,7 @@ BOOST_AUTO_TEST_CASE(seq_in_tuple_t)
 {
   auto map = KeyMap::get<Tuple<Sequence<int>, double, bool>>("tuple");
   auto ref = {"tuple", "tuple[0]", "tuple[0][0]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [6] Tuple< Sequence<T,SZ>, U...>
@@ -71,7 +69,7 @@ BOOST_AUTO_TEST_CASE(bounded_seq_in_tuple_t)
   auto map = KeyMap::get<Tuple<Sequence<int, 2>, double, bool>>("tuple");
   auto ref = {
     "tuple", "tuple[0]", "tuple[0][0]", "tuple[0][1]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [7] Tuple< Tuple<T...>, U...>
@@ -80,7 +78,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_tuple_t)
   auto map = KeyMap::get<Tuple<Tuple<int, float>, double, bool>>("tuple");
   auto ref = {
     "tuple", "tuple[0]", "tuple[0][0]", "tuple[0][1]", "tuple[1]", "tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [8] Sequence< Tuple<T...> >
@@ -88,7 +86,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_t)
 {
   auto map = KeyMap::get<Sequence<Tuple<int, float>>>("seqtuple");
   auto ref = {"seqtuple", "seqtuple[0]", "seqtuple[0][0]", "seqtuple[0][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [9] Sequence< Tuple<T...>, SZ >
@@ -102,7 +100,7 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_2_t)
               "seqtuple[1]",
               "seqtuple[1][0]",
               "seqtuple[1][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [10] Sequence< Sequence<T> >
@@ -110,7 +108,7 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_t)
 {
   auto map = KeyMap::get<Sequence<Sequence<int>>>("seqseq");
   auto ref = {"seqseq", "seqseq[0]", "seqseq[0][0]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [11] Sequence< Sequence<T,SZ> >
@@ -118,7 +116,7 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_t)
 {
   auto map = KeyMap::get<Sequence<Sequence<int, 2>>>("seqseq");
   auto ref = {"seqseq", "seqseq[0]", "seqseq[0][0]", "seqseq[0][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [12] Sequence< Sequence<T,SZ> >
@@ -127,7 +125,7 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_2_t)
   auto map = KeyMap::get<Sequence<Sequence<int>, 2>>("seqseq");
   auto ref = {
     "seqseq", "seqseq[0]", "seqseq[0][0]", "seqseq[1]", "seqseq[1][0]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [13] Sequence< Sequence<T,SZ>, SZ >
@@ -141,7 +139,7 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_2_t)
               "seqseq[1]",
               "seqseq[1][0]",
               "seqseq[1][1]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/keymap_table_t.cc b/fhiclcpp/test/types/keymap_table_t.cc
index 1eaeaff..6e4c979 100644
--- a/fhiclcpp/test/types/keymap_table_t.cc
+++ b/fhiclcpp/test/types/keymap_table_t.cc
@@ -10,7 +10,7 @@
 #define BOOST_TEST_MODULE (keymap test with tables)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
+
 #include "fhiclcpp/test/types/KeyMap.h"
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
@@ -18,7 +18,6 @@
 #include "fhiclcpp/types/TableFragment.h"
 #include "fhiclcpp/types/Tuple.h"
 
-#include <iostream>
 #include <string>
 #include <vector>
 
@@ -27,7 +26,6 @@ using namespace fhicl::detail;
 using namespace std;
 
 namespace {
-
   struct S {
     Atom<int> test{Name("atom")};
     Sequence<int, 2> seq{Name("sequence")};
@@ -50,7 +48,7 @@ BOOST_AUTO_TEST_CASE(table_t)
               "table.tuple[0]",
               "table.tuple[1]",
               "table.tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [15] Sequence< Table<S> >
@@ -68,7 +66,7 @@ BOOST_AUTO_TEST_CASE(table_in_seq_t)
               "seqtable[0].tuple[0]",
               "seqtable[0].tuple[1]",
               "seqtable[0].tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [16] Sequence< Table<S>,2 >
@@ -94,7 +92,7 @@ BOOST_AUTO_TEST_CASE(table_in_seq_2_t)
               "seqtable[1].tuple[0]",
               "seqtable[1].tuple[1]",
               "seqtable[1].tuple[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [17] Tuple< Table<S>, U... >
@@ -113,7 +111,7 @@ BOOST_AUTO_TEST_CASE(table_in_tuple_t)
               "tuptable[0].tuple[2]",
               "tuptable[1]",
               "tuptable[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [18] Tuple< Sequence< Table<S> >, U... >
@@ -133,7 +131,7 @@ BOOST_AUTO_TEST_CASE(seqtable_in_tuple_t)
               "seqtuptable[0][0].tuple[2]",
               "seqtuptable[1]",
               "seqtuptable[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [19] Tuple< Sequence< Table<S>, SZ >, U... >
@@ -163,7 +161,7 @@ BOOST_AUTO_TEST_CASE(seqtable_2_in_tuple_t)
               "seqtuptable[0][1].tuple[2]",
               "seqtuptable[1]",
               "seqtuptable[2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [20] Sequence< Tuple< Table<S>, U... > >
@@ -183,7 +181,7 @@ BOOST_AUTO_TEST_CASE(tuptable_in_seq_t)
               "tupseqtable[0][0].tuple[2]",
               "tupseqtable[0][1]",
               "tupseqtable[0][2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [21] Sequence< Tuple< Table<S>, U... >, SZ >
@@ -216,21 +214,21 @@ BOOST_AUTO_TEST_CASE(tuptable_in_seq_2_t)
               "tupseqtable[1][0].tuple[2]",
               "tupseqtable[1][1]",
               "tupseqtable[1][2]"};
-  CET_CHECK_EQUAL_COLLECTIONS(map, ref);
+  BOOST_TEST(map == ref, boost::test_tools::per_element{});
 }
 
 // [21] Sequence< Tuple< Table<S>, U... >, SZ >
 BOOST_AUTO_TEST_CASE(tablefragment_t)
 {
   TableFragment<S> tf;
-  BOOST_CHECK_EQUAL(tf().test.key(), "atom");
+  BOOST_TEST(tf().test.key() == "atom");
 
   {
     KeyMap km;
     km.walk_over(tf().seq);
     auto mapseq = km.result();
     auto refseq = {"sequence", "sequence[0]", "sequence[1]"};
-    CET_CHECK_EQUAL_COLLECTIONS(mapseq, refseq);
+    BOOST_TEST(mapseq == refseq, boost::test_tools::per_element{});
   }
 
   {
@@ -238,7 +236,7 @@ BOOST_AUTO_TEST_CASE(tablefragment_t)
     km.walk_over(tf().tuple);
     auto maptup = km.result();
     auto reftup = {"tuple", "tuple[0]", "tuple[1]", "tuple[2]"};
-    CET_CHECK_EQUAL_COLLECTIONS(maptup, reftup);
+    BOOST_TEST(maptup == reftup, boost::test_tools::per_element{});
   }
 }
 
diff --git a/fhiclcpp/test/types/keys_to_ignore_t.cc b/fhiclcpp/test/types/keys_to_ignore_t.cc
index b4b3c89..a774690 100644
--- a/fhiclcpp/test/types/keys_to_ignore_t.cc
+++ b/fhiclcpp/test/types/keys_to_ignore_t.cc
@@ -8,7 +8,6 @@
 
 #include "cetlib/quiet_unit_test.hpp"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/ParameterSet.h"
 #include "fhiclcpp/make_ParameterSet.h"
 #include "fhiclcpp/types/KeysToIgnore.h"
@@ -63,7 +62,7 @@ BOOST_AUTO_TEST_CASE(template_test_1)
 {
   auto const& ref = Config::KeysToIgnore{}();
   auto const& test = fhicl::KeysToIgnore<Config::KeysToIgnore>{}();
-  CET_CHECK_EQUAL_COLLECTIONS(test, ref);
+  BOOST_TEST(test == ref);
 }
 
 BOOST_AUTO_TEST_CASE(template_test_2)
@@ -71,7 +70,7 @@ BOOST_AUTO_TEST_CASE(template_test_2)
   auto const& ref = {"a", "testing", "z"};
   auto const& test =
     fhicl::KeysToIgnore<Config::KeysToIgnore, KeysToIgnore2>{}();
-  CET_CHECK_EQUAL_COLLECTIONS(test, ref);
+  BOOST_TEST(test == ref, boost::test_tools::per_element{});
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/optionalDelegatedParameter_t.cc b/fhiclcpp/test/types/optionalDelegatedParameter_t.cc
index 712a3e5..670d086 100644
--- a/fhiclcpp/test/types/optionalDelegatedParameter_t.cc
+++ b/fhiclcpp/test/types/optionalDelegatedParameter_t.cc
@@ -1,7 +1,7 @@
 #define BOOST_TEST_MODULE (optionalDelegatedParameter test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
+
 #include "fhiclcpp/test/types/FixtureBase.h"
 #include "fhiclcpp/types/OptionalDelegatedParameter.h"
 
diff --git a/fhiclcpp/test/types/return_optionalValues_from_fcl_t.cc b/fhiclcpp/test/types/return_optionalValues_from_fcl_t.cc
index 256d8d1..465d919 100644
--- a/fhiclcpp/test/types/return_optionalValues_from_fcl_t.cc
+++ b/fhiclcpp/test/types/return_optionalValues_from_fcl_t.cc
@@ -19,7 +19,6 @@
 #include "fhiclcpp/types/Table.h"
 #include "fhiclcpp/types/Tuple.h"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/test/types/FixtureBase.h"
 
 #include <iostream>
@@ -31,10 +30,7 @@ using namespace std;
 
 namespace {
 
-  double const tolerance [[maybe_unused]] =
-    std::numeric_limits<double>::epsilon();
-  double const ftolerance [[maybe_unused]] =
-    std::numeric_limits<float>::epsilon();
+  constexpr auto tolerance = std::numeric_limits<double>::epsilon();
 
   struct Physics {
     Tuple<std::string, double> energyCutoff{Name("energyCutoff")};
@@ -69,10 +65,10 @@ BOOST_AUTO_TEST_CASE(optAtom_t)
 {
   int i{};
   std::string n;
-  BOOST_CHECK(config().atom(i));
-  BOOST_CHECK(!config().name(n));
-  BOOST_CHECK_EQUAL(i, 5);
-  BOOST_CHECK(n.empty());
+  BOOST_TEST(config().atom(i));
+  BOOST_TEST(!config().name(n));
+  BOOST_TEST(i == 5);
+  BOOST_TEST(n.empty());
 }
 
 // [2] OptionalTable<T>
@@ -80,18 +76,19 @@ BOOST_AUTO_TEST_CASE(optTable_t)
 {
   Physics phys;
   std::string name;
-  BOOST_CHECK(config().physics(phys));
-  BOOST_CHECK(phys.moniker(name));
-  BOOST_CHECK_EQUAL(name, "Johnny");
-  BOOST_CHECK_EQUAL(phys.energyCutoff.get<0>(), "QGSP");
-  BOOST_CHECK_CLOSE_FRACTION(phys.energyCutoff.get<1>(), 14.6, tolerance);
+  BOOST_TEST(config().physics(phys));
+  BOOST_TEST(phys.moniker(name));
+  BOOST_TEST(name == "Johnny");
+  BOOST_TEST(phys.energyCutoff.get<0>() == "QGSP");
+  BOOST_TEST(phys.energyCutoff.get<1>() == 14.6, tolerance);
 }
 
 // [3] OptionalSequence<T>
 BOOST_AUTO_TEST_CASE(optSeqVector_t1)
 {
   std::vector<int> intList;
-  BOOST_CHECK(!config().list1(intList));
+  BOOST_TEST(!config().list1.hasValue());
+  BOOST_TEST(!config().list1(intList));
 }
 
 // [4] OptionalSequence<T,SIZE>
@@ -99,20 +96,21 @@ BOOST_AUTO_TEST_CASE(optSeqVector_t2)
 {
   std::array<int, 4> intList;
   auto ref = {1, 2, 4, 8};
-  BOOST_CHECK(config().list2(intList));
-  CET_CHECK_EQUAL_COLLECTIONS(intList, ref);
+  BOOST_TEST(config().list2.hasValue());
+  BOOST_TEST(config().list2(intList));
+  BOOST_TEST(intList == ref, boost::test_tools::per_element{});
 }
 
 // [5] OptionalSequence<T>
 BOOST_AUTO_TEST_CASE(optSeqVector_t3)
 {
   std::vector<std::array<int, 2>> intLists;
-  BOOST_CHECK(config().list3(intLists));
+  BOOST_TEST(config().list3(intLists));
 
   decltype(intLists) const ref{{{0, 1}}, {{1, 2}}, {{2, 4}}, {{3, 8}}};
   std::size_t i{};
   for (auto const& list : intLists) {
-    CET_CHECK_EQUAL_COLLECTIONS(list, ref[i]);
+    BOOST_TEST(list == ref[i], boost::test_tools::per_element{});
     ++i;
   }
 }
@@ -121,14 +119,14 @@ BOOST_AUTO_TEST_CASE(optSeqVector_t3)
 BOOST_AUTO_TEST_CASE(optSeqVector_t4)
 {
   std::array<Composer, 4> composers;
-  BOOST_CHECK(config().list4(composers));
+  BOOST_TEST(config().list4(composers));
 
   std::array<std::string, 4> const ref{
     {"Mozart", "Beethoven", "Brahms", "Mahler"}};
 
   std::size_t i{};
   for (auto const& comp : composers) {
-    BOOST_CHECK_EQUAL(comp.composer(), ref[i]);
+    BOOST_TEST(comp.composer() == ref[i]);
     ++i;
   }
 }
@@ -139,7 +137,7 @@ BOOST_AUTO_TEST_CASE(optTuple_t)
   enum composer_t { Mozart, Beethoven, Brahms, Mahler };
 
   std::array<Composer, 4> composers;
-  BOOST_CHECK(config().list4(composers));
+  BOOST_TEST(config().list4(composers));
 
   std::array<int, 4> const symphonyNumbers{{41, 3, 0, 8}};
   std::array<std::string, 4> const symphonyMonikers{
@@ -149,13 +147,13 @@ BOOST_AUTO_TEST_CASE(optTuple_t)
 
     std::tuple<int, std::string> moniker;
     if (i != static_cast<composer_t>(Brahms)) {
-      BOOST_CHECK(comp.aSymphonyMoniker(moniker));
+      BOOST_TEST(comp.aSymphonyMoniker(moniker));
     } else {
-      BOOST_CHECK(!comp.aSymphonyMoniker(moniker));
+      BOOST_TEST(!comp.aSymphonyMoniker(moniker));
     }
 
-    BOOST_CHECK_EQUAL(std::get<int>(moniker), symphonyNumbers[i]);
-    BOOST_CHECK_EQUAL(std::get<std::string>(moniker), symphonyMonikers[i]);
+    BOOST_TEST(std::get<int>(moniker) == symphonyNumbers[i]);
+    BOOST_TEST(std::get<std::string>(moniker) == symphonyMonikers[i]);
     ++i;
   }
 }
diff --git a/fhiclcpp/test/types/return_table_values_from_fcl_t.cc b/fhiclcpp/test/types/return_table_values_from_fcl_t.cc
index ef80a66..95d3455 100644
--- a/fhiclcpp/test/types/return_table_values_from_fcl_t.cc
+++ b/fhiclcpp/test/types/return_table_values_from_fcl_t.cc
@@ -30,7 +30,7 @@ using namespace std;
 
 namespace {
 
-  double const tolerance = std::numeric_limits<double>::epsilon();
+  constexpr auto tolerance = std::numeric_limits<double>::epsilon();
 
   struct RefS {
 
@@ -113,7 +113,7 @@ BOOST_FIXTURE_TEST_SUITE(values_from_fcl, Fixture)
 BOOST_AUTO_TEST_CASE(table_t)
 {
   RefS ref(4, 3, 6, 8, "something", false);
-  BOOST_CHECK_EQUAL(config().table(), ref);
+  BOOST_TEST(config().table() == ref);
 }
 
 // [15] Sequence< Table<S> >
@@ -123,7 +123,7 @@ BOOST_AUTO_TEST_CASE(table_in_seq_t)
   auto it = ref.begin();
 
   for (auto const& table : config().vecOfTable())
-    BOOST_CHECK_EQUAL(table, *it++);
+    BOOST_TEST(table == *it++);
 }
 
 // [16] Sequence< Table<S>,2 >
@@ -135,16 +135,16 @@ BOOST_AUTO_TEST_CASE(table_in_seq_2_t)
   auto it = ref.begin();
 
   for (auto const& table : config().arrOfTable())
-    BOOST_CHECK_EQUAL(table, *it++);
+    BOOST_TEST(table == *it++);
 }
 
 // [17] Tuple< Table<S>, U... >
 BOOST_AUTO_TEST_CASE(table_in_tuple_t)
 {
   RefS ref{3, 13, 103, 3, "tup0", true};
-  BOOST_CHECK_EQUAL(config().tupWithTable.get<0>(), ref);
-  BOOST_CHECK_EQUAL(config().tupWithTable.get<1>(), 981);
-  BOOST_CHECK_CLOSE_FRACTION(config().tupWithTable.get<2>(), 581.1, tolerance);
+  BOOST_TEST(config().tupWithTable.get<0>() == ref);
+  BOOST_TEST(config().tupWithTable.get<1>() == 981);
+  BOOST_TEST(config().tupWithTable.get<2>() == 581.1, tolerance);
 }
 
 // [18] Tuple< Sequence< Table<S> >, U... >
@@ -153,10 +153,9 @@ BOOST_AUTO_TEST_CASE(vec_table_in_tuple_t)
   auto ref = {RefS{4, 14, 104, 4, "tup0", true}};
   auto it = ref.begin();
   for (auto const& table : config().tupWithVecTable.get<0>())
-    BOOST_CHECK_EQUAL(table, *it++);
-  BOOST_CHECK_EQUAL(config().tupWithVecTable.get<1>(), 345);
-  BOOST_CHECK_CLOSE_FRACTION(
-    config().tupWithVecTable.get<2>(), 234.14, tolerance);
+    BOOST_TEST(table == *it++);
+  BOOST_TEST(config().tupWithVecTable.get<1>() == 345);
+  BOOST_TEST(config().tupWithVecTable.get<2>() == 234.14, tolerance);
 }
 
 // [19] Tuple< Sequence< Table<S>, SZ >, U... >
@@ -167,10 +166,9 @@ BOOST_AUTO_TEST_CASE(arr_table_in_tuple_t)
   auto it = ref.begin();
 
   for (auto const& table : config().tupWithArrTable.get<0>())
-    BOOST_CHECK_EQUAL(table, *it++);
-  BOOST_CHECK_EQUAL(config().tupWithArrTable.get<1>(), 789);
-  BOOST_CHECK_CLOSE_FRACTION(
-    config().tupWithArrTable.get<2>(), 17.06, tolerance);
+    BOOST_TEST(table == *it++);
+  BOOST_TEST(config().tupWithArrTable.get<1>() == 789);
+  BOOST_TEST(config().tupWithArrTable.get<2>() == 17.06, tolerance);
 }
 
 // [20] Sequence< Tuple< Table<S>, U... > >
@@ -179,9 +177,9 @@ BOOST_AUTO_TEST_CASE(tup_table_in_vec_t)
   auto ref = RefS{7, 17, 107, 7, "tup0", true};
 
   for (auto const& tup : config().vecWithTupTable()) {
-    BOOST_CHECK_EQUAL(std::get<0>(tup), ref);
-    BOOST_CHECK_EQUAL(std::get<1>(tup), 4);
-    BOOST_CHECK_CLOSE_FRACTION(std::get<2>(tup), 1.0004, tolerance);
+    BOOST_TEST(std::get<0>(tup) == ref);
+    BOOST_TEST(std::get<1>(tup) == 4);
+    BOOST_TEST(std::get<2>(tup) == 1.0004, tolerance);
   }
 }
 
@@ -198,9 +196,9 @@ BOOST_AUTO_TEST_CASE(tup_table_in_arr_t)
   auto it_ds = ref_ds.begin();
 
   for (auto const& tup : config().arrWithTupTable()) {
-    BOOST_CHECK_EQUAL(std::get<0>(tup), *it_ts++);
-    BOOST_CHECK_EQUAL(std::get<1>(tup), *it_is++);
-    BOOST_CHECK_CLOSE_FRACTION(std::get<2>(tup), *it_ds++, tolerance);
+    BOOST_TEST(std::get<0>(tup) == *it_ts++);
+    BOOST_TEST(std::get<1>(tup) == *it_is++);
+    BOOST_TEST(std::get<2>(tup) == *it_ds++, tolerance);
   }
 }
 
@@ -208,7 +206,7 @@ BOOST_AUTO_TEST_CASE(tup_table_in_arr_t)
 BOOST_AUTO_TEST_CASE(tableFragment_t)
 {
   auto ref = RefS{10, 20, 200, 10, "tup", false};
-  BOOST_CHECK_EQUAL(config().tFragment(), ref);
+  BOOST_TEST(config().tFragment() == ref);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/return_types_t.cc b/fhiclcpp/test/types/return_types_t.cc
index 76a733c..fdda831 100644
--- a/fhiclcpp/test/types/return_types_t.cc
+++ b/fhiclcpp/test/types/return_types_t.cc
@@ -30,7 +30,7 @@ namespace {
   require_type_as(T& t)
   {
     auto rt = t();
-    BOOST_CHECK((std::is_same_v<R, decltype(rt)>));
+    BOOST_TEST((std::is_same_v<R, decltype(rt)>));
   }
 }
 
diff --git a/fhiclcpp/test/types/return_types_table_t.cc b/fhiclcpp/test/types/return_types_table_t.cc
index 70677a7..68ae7ff 100644
--- a/fhiclcpp/test/types/return_types_table_t.cc
+++ b/fhiclcpp/test/types/return_types_table_t.cc
@@ -62,7 +62,7 @@ namespace {
   require_type_as(T& t [[maybe_unused]])
   {
     auto rt = t();
-    BOOST_CHECK((std::is_same<R, decltype(rt)>::value));
+    BOOST_TEST((std::is_same<R, decltype(rt)>::value));
   }
 
   struct S {
diff --git a/fhiclcpp/test/types/return_value_defaults_t.cc b/fhiclcpp/test/types/return_value_defaults_t.cc
index 7772362..74500c0 100644
--- a/fhiclcpp/test/types/return_value_defaults_t.cc
+++ b/fhiclcpp/test/types/return_value_defaults_t.cc
@@ -10,12 +10,10 @@
 
 #include "cetlib/quiet_unit_test.hpp"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
 #include "fhiclcpp/types/Tuple.h"
 
-#include <iostream>
 #include <string>
 #include <vector>
 
@@ -29,7 +27,7 @@ BOOST_AUTO_TEST_SUITE(types_return_value_defaults_test)
 BOOST_AUTO_TEST_CASE(one_atom_t)
 {
   Atom<int> test{Name("atom"), 4};
-  BOOST_CHECK_EQUAL(test(), 4);
+  BOOST_TEST(test() == 4);
 }
 
 // [2] Sequence<T>
@@ -37,11 +35,10 @@ BOOST_AUTO_TEST_CASE(one_sequence_t)
 {
   auto ref = {1, 2, 4};
   Sequence<int> test{Name("sequence"), ref};
-  auto rval = test();
-  CET_CHECK_EQUAL_COLLECTIONS(rval, ref);
+  BOOST_TEST(test() == ref, boost::test_tools::per_element{});
   std::size_t i{};
   for (auto const& elem : ref)
-    BOOST_CHECK_EQUAL(elem, test(i++));
+    BOOST_TEST(elem == test(i++));
 }
 
 // [3] Sequence<T,SZ>
@@ -49,21 +46,20 @@ BOOST_AUTO_TEST_CASE(one_sequence_2_t)
 {
   auto ref = {5, 7};
   Sequence<int, 2> test{Name("sequence"), ref};
-  auto rval = test();
-  CET_CHECK_EQUAL_COLLECTIONS(rval, ref);
+  BOOST_TEST(test() == ref, boost::test_tools::per_element{});
 
   std::size_t i{};
   for (auto const& elem : ref)
-    BOOST_CHECK_EQUAL(elem, test(i++));
+    BOOST_TEST(elem == test(i++));
 }
 
 // [4] Tuple<T...>
 BOOST_AUTO_TEST_CASE(one_tuple_t)
 {
   Tuple<int, double, bool> test{Name("tuple"), {4, 1.5, false}};
-  BOOST_CHECK_EQUAL(test.get<0>(), 4);
-  BOOST_CHECK_EQUAL(test.get<1>(), 1.5);
-  BOOST_CHECK_EQUAL(test.get<2>(), false);
+  BOOST_TEST(test.get<0>() == 4);
+  BOOST_TEST(test.get<1>() == 1.5);
+  BOOST_TEST(test.get<2>() == false);
 }
 
 // [5] Tuple< Sequence<T>, U...>
@@ -71,10 +67,9 @@ BOOST_AUTO_TEST_CASE(seq_in_tuple_t)
 {
   auto ref = {1, 3, 5};
   Tuple<Sequence<int>, double, bool> test{Name("tuple"), {ref, 4.6, true}};
-  auto rval = test.get<0>();
-  CET_CHECK_EQUAL_COLLECTIONS(rval, ref);
-  BOOST_CHECK_EQUAL(test.get<1>(), 4.6);
-  BOOST_CHECK_EQUAL(test.get<2>(), true);
+  BOOST_TEST(test.get<0>() == ref, boost::test_tools::per_element{});
+  BOOST_TEST(test.get<1>() == 4.6);
+  BOOST_TEST(test.get<2>() == true);
 }
 
 // [6] Tuple< Sequence<T,SZ>, U...>
@@ -82,10 +77,9 @@ BOOST_AUTO_TEST_CASE(bounded_seq_in_tuple_t)
 {
   auto ref = {9, 15};
   Tuple<Sequence<int, 2>, double, bool> test{Name("tuple"), {ref, 0.2, false}};
-  auto rval = test.get<0>();
-  CET_CHECK_EQUAL_COLLECTIONS(rval, ref);
-  BOOST_CHECK_EQUAL(test.get<1>(), 0.2);
-  BOOST_CHECK_EQUAL(test.get<2>(), false);
+  BOOST_TEST(test.get<0>() == ref, boost::test_tools::per_element{});
+  BOOST_TEST(test.get<1>() == 0.2);
+  BOOST_TEST(test.get<2>() == false);
 }
 
 // [7] Tuple< Tuple<T...>, U...>
@@ -93,11 +87,11 @@ BOOST_AUTO_TEST_CASE(tuple_in_tuple_t)
 {
   Tuple<Tuple<int, float>, double, bool> test{Name("tuple"),
                                               {{4, 3.7f}, 8.1, true}};
-  auto tuple0 [[maybe_unused]] = test.get<0>();
-  BOOST_CHECK_EQUAL(std::get<0>(tuple0), 4);
-  BOOST_CHECK_EQUAL(std::get<1>(tuple0), 3.7f);
-  BOOST_CHECK_EQUAL(test.get<1>(), 8.1);
-  BOOST_CHECK_EQUAL(test.get<2>(), true);
+  auto const tuple0 = test.get<0>();
+  BOOST_TEST(std::get<0>(tuple0) == 4);
+  BOOST_TEST(std::get<1>(tuple0) == 3.7f);
+  BOOST_TEST(test.get<1>() == 8.1);
+  BOOST_TEST(test.get<2>() == true);
 }
 
 // [8] Sequence< Tuple<T...> >
@@ -110,8 +104,8 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_t)
                                    {{2, 5.4f}, {4, 104.5f}, {8, 15.3f}}};
   std::size_t i{};
   for (auto const& elem : test()) {
-    BOOST_CHECK_EQUAL(std::get<0>(elem), std::get<0>(ref_vec.at(i)));
-    BOOST_CHECK_EQUAL(std::get<1>(elem), std::get<1>(ref_vec.at(i++)));
+    BOOST_TEST(std::get<0>(elem) == std::get<0>(ref_vec.at(i)));
+    BOOST_TEST(std::get<1>(elem) == std::get<1>(ref_vec.at(i++)));
   }
 }
 
@@ -124,8 +118,8 @@ BOOST_AUTO_TEST_CASE(tuple_in_seq_2_t)
   Sequence<Tuple<int, float>, 2> test{Name("seqtuple"), {{1, 2.3f}, {9, 3.2f}}};
   std::size_t i{};
   for (auto const& elem : test()) {
-    BOOST_CHECK_EQUAL(std::get<0>(elem), std::get<0>(ref_vec.at(i)));
-    BOOST_CHECK_EQUAL(std::get<1>(elem), std::get<1>(ref_vec.at(i++)));
+    BOOST_TEST(std::get<0>(elem) == std::get<0>(ref_vec.at(i)));
+    BOOST_TEST(std::get<1>(elem) == std::get<1>(ref_vec.at(i++)));
   }
 }
 
@@ -134,17 +128,16 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_t)
 {
   auto ref_vec = std::vector<std::vector<int>>{{1, 5, 7}, {2}};
   Sequence<Sequence<int>> test{Name("seqseq"), {{1, 5, 7}, {2}}};
-  auto rval = test();
   std::size_t i{};
   for (auto const& val : test()) {
     auto ref = ref_vec.at(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref);
   }
 
   i = 0ul;
   for (auto const& ref : ref_vec) {
     auto val = test(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref);
   }
 }
 
@@ -153,11 +146,10 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_t)
 {
   auto ref_vec = std::vector<std::array<int, 2>>{{{1, 2}}};
   Sequence<Sequence<int, 2>> test{Name("seqseq"), {{1, 2}}};
-  auto rval = test();
   std::size_t i{};
   for (auto const& val : test()) {
     auto ref = ref_vec.at(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref);
   }
 }
 
@@ -171,7 +163,7 @@ BOOST_AUTO_TEST_CASE(seq_in_seq_2_t)
   std::size_t i{};
   for (auto const& val : test()) {
     auto ref = ref_vec.at(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref);
   }
 }
 
@@ -185,7 +177,7 @@ BOOST_AUTO_TEST_CASE(seq_2_in_seq_2_t)
   std::size_t i{};
   for (auto const& val : test()) {
     auto ref = ref_vec.at(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref);
   }
 }
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/return_values_from_fcl_t.cc b/fhiclcpp/test/types/return_values_from_fcl_t.cc
index e1a3f53..2e5b68d 100644
--- a/fhiclcpp/test/types/return_values_from_fcl_t.cc
+++ b/fhiclcpp/test/types/return_values_from_fcl_t.cc
@@ -10,13 +10,11 @@
 #define BOOST_TEST_MODULE (return values from fcl)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/test/types/FixtureBase.h"
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
 #include "fhiclcpp/types/Tuple.h"
 
-#include <iostream>
 #include <string>
 #include <vector>
 
@@ -26,8 +24,8 @@ using namespace std;
 
 namespace {
 
-  double const tolerance = std::numeric_limits<double>::epsilon();
-  double const ftolerance = std::numeric_limits<float>::epsilon();
+  constexpr auto tolerance = std::numeric_limits<double>::epsilon();
+  constexpr auto ftolerance = std::numeric_limits<float>::epsilon();
 
   struct Configuration {
     Atom<int> atom{Name("atom")};
@@ -59,7 +57,7 @@ BOOST_FIXTURE_TEST_SUITE(values_from_fcl, Fixture)
 // [1] Atom<T>
 BOOST_AUTO_TEST_CASE(atom)
 {
-  BOOST_CHECK_EQUAL(config().atom(), 5);
+  BOOST_TEST(config().atom() == 5);
 }
 
 // [2] Sequence<T>
@@ -67,7 +65,7 @@ BOOST_AUTO_TEST_CASE(seq_vector)
 {
   auto ref = {3, 5, 8};
   auto val = config().vec();
-  CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+  BOOST_TEST(val == ref, boost::test_tools::per_element{});
 }
 
 // [3] Sequence<T,SZ>
@@ -75,15 +73,15 @@ BOOST_AUTO_TEST_CASE(seq_array)
 {
   auto ref = {4, 9};
   auto val = config().arr();
-  CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+  BOOST_TEST(val == ref, boost::test_tools::per_element{});
 }
 
 // [4] Tuple<T...>
 BOOST_AUTO_TEST_CASE(tuple)
 {
-  BOOST_CHECK_EQUAL(config().tuple.get<0>(), 5);
-  BOOST_CHECK_CLOSE_FRACTION(config().tuple.get<1>(), 4.3, tolerance);
-  BOOST_CHECK_EQUAL(config().tuple.get<2>(), true);
+  BOOST_TEST(config().tuple.get<0>() == 5);
+  BOOST_TEST(config().tuple.get<1>() == 4.3, tolerance);
+  BOOST_TEST(config().tuple.get<2>() == true);
 }
 
 // [5] Tuple< Sequence<T>, U...>
@@ -91,10 +89,9 @@ BOOST_AUTO_TEST_CASE(tuple_with_vector)
 {
   auto ref = {4, 1, 4, 67, 89};
   auto val = config().tupWithVec.get<0>();
-  CET_CHECK_EQUAL_COLLECTIONS(val, ref);
-
-  BOOST_CHECK_CLOSE_FRACTION(config().tupWithVec.get<1>(), 4.56789, tolerance);
-  BOOST_CHECK_EQUAL(config().tupWithVec.get<2>(), false);
+  BOOST_TEST(val == ref, boost::test_tools::per_element{});
+  BOOST_TEST(config().tupWithVec.get<1>() == 4.56789, tolerance);
+  BOOST_TEST(config().tupWithVec.get<2>() == false);
 }
 
 // [6] Tuple< Sequence<T,SZ>, U...>
@@ -102,33 +99,31 @@ BOOST_AUTO_TEST_CASE(tuple_with_array)
 {
   auto ref = {5, 16};
   auto val = config().tupWithArr.get<0>();
-  CET_CHECK_EQUAL_COLLECTIONS(val, ref);
-
-  BOOST_CHECK_CLOSE_FRACTION(config().tupWithArr.get<1>(), 46.9, tolerance);
-  BOOST_CHECK_EQUAL(config().tupWithArr.get<2>(), true);
+  BOOST_TEST(val == ref, boost::test_tools::per_element{});
+  BOOST_TEST(config().tupWithArr.get<1>() == 46.9, tolerance);
+  BOOST_TEST(config().tupWithArr.get<2>() == true);
 }
 
 // [7] Tuple< Tuple<T...>, U...>
 BOOST_AUTO_TEST_CASE(tuple_with_tuple)
 {
   auto tuple0 = config().tupWithTup.get<0>();
-  BOOST_CHECK_EQUAL(std::get<0>(tuple0), 4);
-  BOOST_CHECK_CLOSE_FRACTION(std::get<1>(tuple0), 175.218f, ftolerance);
-  BOOST_CHECK_CLOSE_FRACTION(config().tupWithTup.get<1>(), 87.03, tolerance);
-  BOOST_CHECK_EQUAL(config().tupWithTup.get<2>(), false);
+  BOOST_TEST(std::get<0>(tuple0) == 4);
+  BOOST_TEST(std::get<1>(tuple0) == 175.218f, ftolerance);
+  BOOST_TEST(config().tupWithTup.get<1>() == 87.03, tolerance);
+  BOOST_TEST(config().tupWithTup.get<2>() == false);
 }
 
 // [8] Sequence< Tuple<T...> >
 BOOST_AUTO_TEST_CASE(vec_of_tups)
 {
-
   vector<int> const nums{11, 22};
   vector<string> const strs{"Decay in orbit", "Radiative pion capture"};
 
   size_t i{};
   for (auto const& elem : config().vecWithTup()) {
-    BOOST_CHECK_EQUAL(std::get<0>(elem), nums.at(i));
-    BOOST_CHECK_EQUAL(std::get<1>(elem), strs.at(i++));
+    BOOST_TEST(std::get<0>(elem) == nums.at(i));
+    BOOST_TEST(std::get<1>(elem) == strs.at(i++));
   }
 }
 
@@ -142,9 +137,9 @@ BOOST_AUTO_TEST_CASE(arr_of_tups)
 
   size_t i{};
   for (auto const& elem : config().arrWithTup()) {
-    BOOST_CHECK_EQUAL(std::get<0>(elem), prefixes.at(i));
-    BOOST_CHECK_EQUAL(std::get<1>(elem), nums.at(i++));
-    BOOST_CHECK_EQUAL(std::get<2>(elem), str);
+    BOOST_TEST(std::get<0>(elem) == prefixes.at(i));
+    BOOST_TEST(std::get<1>(elem) == nums.at(i++));
+    BOOST_TEST(std::get<2>(elem) == str);
   }
 }
 
@@ -157,13 +152,13 @@ BOOST_AUTO_TEST_CASE(vec_of_vecs)
 
   for (auto const& val : config().vecOfVec()) {
     auto ref = *it++;
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref, boost::test_tools::per_element{});
   }
 
   size_t i{};
   for (auto const& ref : ref_vec) {
     auto val = config().vecOfVec(i++);
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref, boost::test_tools::per_element{});
   }
 }
 
@@ -176,7 +171,7 @@ BOOST_AUTO_TEST_CASE(vec_of_arrs)
 
   for (auto const& val : config().vecOfArr()) {
     auto ref = *it++;
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref, boost::test_tools::per_element{});
   }
 }
 
@@ -188,7 +183,7 @@ BOOST_AUTO_TEST_CASE(arr_of_vecs)
 
   for (auto const& val : config().arrOfVec()) {
     auto ref = *it++;
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref, boost::test_tools::per_element{});
   }
 }
 
@@ -200,7 +195,7 @@ BOOST_AUTO_TEST_CASE(arr_of_arrs)
 
   for (auto const& val : config().arrOfArr()) {
     auto ref = *it++;
-    CET_CHECK_EQUAL_COLLECTIONS(val, ref);
+    BOOST_TEST(val == ref, boost::test_tools::per_element{});
   }
 }
 
diff --git a/fhiclcpp/test/types/searchAllowedConfiguration_t.cc b/fhiclcpp/test/types/searchAllowedConfiguration_t.cc
index e5299a6..c3f1c58 100644
--- a/fhiclcpp/test/types/searchAllowedConfiguration_t.cc
+++ b/fhiclcpp/test/types/searchAllowedConfiguration_t.cc
@@ -1,7 +1,7 @@
 #define BOOST_TEST_MODULE (search allowed configuration test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
+
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/Sequence.h"
 #include "fhiclcpp/types/Table.h"
@@ -37,23 +37,23 @@ BOOST_AUTO_TEST_SUITE(searchAllowedConfiguration_test)
 BOOST_AUTO_TEST_CASE(table_t)
 {
   Table<S> t{Name{"table"}};
-  BOOST_CHECK(supports_key(t, "atom"));
-  BOOST_CHECK(!supports_key(t, "table.atom"));
-  BOOST_CHECK(!supports_key(t, "table.sequence"));
-  BOOST_CHECK(supports_key(t, "sequence"));
-  BOOST_CHECK(supports_key(t, "sequence[0]"));
-  BOOST_CHECK(!supports_key(t, "[0]"));
-  BOOST_CHECK(supports_key(t, "table2"));
-  BOOST_CHECK(supports_key(t, "tuple2[0][1]"));
-  BOOST_CHECK(supports_key(t, "tuple2[1]"));
+  BOOST_TEST(supports_key(t, "atom"));
+  BOOST_TEST(!supports_key(t, "table.atom"));
+  BOOST_TEST(!supports_key(t, "table.sequence"));
+  BOOST_TEST(supports_key(t, "sequence"));
+  BOOST_TEST(supports_key(t, "sequence[0]"));
+  BOOST_TEST(!supports_key(t, "[0]"));
+  BOOST_TEST(supports_key(t, "table2"));
+  BOOST_TEST(supports_key(t, "tuple2[0][1]"));
+  BOOST_TEST(supports_key(t, "tuple2[1]"));
 }
 
 BOOST_AUTO_TEST_CASE(seqInSeq_t)
 {
   Sequence<Sequence<int, 2>> s{Name{"nestedSequence"}};
-  BOOST_CHECK(supports_key(s, "[0]"));
-  BOOST_CHECK(supports_key(s, "[0][0]"));
-  BOOST_CHECK(supports_key(s, "[0][1]"));
+  BOOST_TEST(supports_key(s, "[0]"));
+  BOOST_TEST(supports_key(s, "[0][0]"));
+  BOOST_TEST(supports_key(s, "[0][1]"));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/table_insertionOperator_t.cc b/fhiclcpp/test/types/table_insertionOperator_t.cc
index 4ba6923..5cb4d8a 100644
--- a/fhiclcpp/test/types/table_insertionOperator_t.cc
+++ b/fhiclcpp/test/types/table_insertionOperator_t.cc
@@ -7,8 +7,7 @@
 #define BOOST_TEST_MODULE (table_insertionOperator_t)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib/test_macros.h"
-#include "cetlib_except/demangle.h"
+
 #include "fhiclcpp/types/Atom.h"
 #include "fhiclcpp/types/OptionalTable.h"
 #include "fhiclcpp/types/Table.h"
@@ -79,7 +78,7 @@ BOOST_AUTO_TEST_CASE(simple)
   oss << config;
   auto const& test = oss.str();
   auto const& ref = reference();
-  BOOST_CHECK_EQUAL(test, ref);
+  BOOST_TEST(test == ref);
 }
 
 BOOST_AUTO_TEST_CASE(logger)
@@ -87,10 +86,10 @@ BOOST_AUTO_TEST_CASE(logger)
   Table<Config> config{Name("config")};
   Logger logger;
   logger << config;
-  BOOST_CHECK_EQUAL(logger.log, reference());
+  BOOST_TEST(logger.log == reference());
 
   Logger const logger2 = (Logger() << config);
-  BOOST_CHECK_EQUAL(logger2.log, reference());
+  BOOST_TEST(logger2.log == reference());
 }
 
 BOOST_AUTO_TEST_CASE(loggerOptional)
@@ -98,10 +97,10 @@ BOOST_AUTO_TEST_CASE(loggerOptional)
   OptionalTable<Config> config{Name("config")};
   Logger logger;
   logger << config;
-  BOOST_CHECK_EQUAL(logger.log, optional_reference());
+  BOOST_TEST(logger.log == optional_reference());
 
   Logger const logger2 = (Logger() << config);
-  BOOST_CHECK_EQUAL(logger2.log, optional_reference());
+  BOOST_TEST(logger2.log == optional_reference());
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/types/tupleAs_t.cc b/fhiclcpp/test/types/tupleAs_t.cc
index fb4b3c2..0414b78 100644
--- a/fhiclcpp/test/types/tupleAs_t.cc
+++ b/fhiclcpp/test/types/tupleAs_t.cc
@@ -7,16 +7,12 @@
 #define BOOST_TEST_MODULE (tupleAs test)
 
 #include "cetlib/quiet_unit_test.hpp"
-#include "cetlib_except/demangle.h"
 
-#include "cetlib/test_macros.h"
 #include "fhiclcpp/test/types/FixtureBase.h"
 #include "fhiclcpp/types/OptionalTupleAs.h"
 #include "fhiclcpp/types/Sequence.h"
 #include "fhiclcpp/types/TupleAs.h"
 
-#include <array>
-#include <iostream>
 #include <string>
 #include <vector>
 
@@ -94,42 +90,42 @@ BOOST_FIXTURE_TEST_SUITE(tupleAs_test, Fixture)
 BOOST_AUTO_TEST_CASE(tupleAs_simple)
 {
   ThreeNumbers const& tn1 = config().tn1();
-  BOOST_CHECK_EQUAL(tn1.i_, 1);
-  BOOST_CHECK_EQUAL(tn1.j_, 9);
-  BOOST_CHECK_EQUAL(tn1.k_, 17);
+  BOOST_TEST(tn1.i_ == 1);
+  BOOST_TEST(tn1.j_ == 9);
+  BOOST_TEST(tn1.k_ == 17);
 }
 
 BOOST_AUTO_TEST_CASE(tupleAs_default_value)
 {
   ThreeNumbers const& tn2 = config().tn2();
-  BOOST_CHECK_EQUAL(tn2.i_, 1);
-  BOOST_CHECK_EQUAL(tn2.j_, 3);
-  BOOST_CHECK_EQUAL(tn2.k_, 5);
+  BOOST_TEST(tn2.i_ == 1);
+  BOOST_TEST(tn2.j_ == 3);
+  BOOST_TEST(tn2.k_ == 5);
 }
 
 BOOST_AUTO_TEST_CASE(tupleAs_toVector)
 {
   ToVector const& v = config().toVector();
-  auto const& ref = {5, 10, 15, 20};
-  CET_CHECK_EQUAL_COLLECTIONS(v.value_, ref);
+  auto const ref = {5, 10, 15, 20};
+  BOOST_TEST(v.value_ == ref, boost::test_tools::per_element{});
 }
 
 BOOST_AUTO_TEST_CASE(tupleAs_inSequence)
 {
   auto const& people = config().people();
-  auto const& ref = {Person{"Alice", 1},
-                     Person{"Bob", 2},
-                     Person{"Charlie", 3},
-                     Person{"Danielle", 4},
-                     Person{"Edgar", 5}};
-  CET_CHECK_EQUAL_COLLECTIONS(people, ref);
+  auto const ref = {Person{"Alice", 1},
+                    Person{"Bob", 2},
+                    Person{"Charlie", 3},
+                    Person{"Danielle", 4},
+                    Person{"Edgar", 5}};
+  BOOST_TEST(people == ref, boost::test_tools::per_element{});
 }
 
 BOOST_AUTO_TEST_CASE(tupleAs_inSequence_2)
 {
   auto const& people = config().kids();
-  auto const& ref = {Person{"Billy", 10}, Person{"Susie", 14}};
-  CET_CHECK_EQUAL_COLLECTIONS(people, ref);
+  auto const ref = {Person{"Billy", 10}, Person{"Susie", 14}};
+  BOOST_TEST(people == ref, boost::test_tools::per_element{});
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/test/values_test.cc b/fhiclcpp/test/values_test.cc
index 400ecd0..da82023 100644
--- a/fhiclcpp/test/values_test.cc
+++ b/fhiclcpp/test/values_test.cc
@@ -35,32 +35,32 @@ BOOST_AUTO_TEST_CASE(bool_values) // test atoms "true" and "false"
   {
     ParameterSet pset;
     pset.put<string>("b11", "true");
-    BOOST_CHECK(pset.is_key_to_atom("b11"));
-    BOOST_CHECK(!pset.is_key_to_sequence("b11"));
-    BOOST_CHECK(!pset.is_key_to_table("b11"));
-    BOOST_CHECK_EQUAL(pset.to_string(), "b11:\"true\"");
-    BOOST_CHECK(pset.get<bool>("b11"));
+    BOOST_TEST(pset.is_key_to_atom("b11"));
+    BOOST_TEST(!pset.is_key_to_sequence("b11"));
+    BOOST_TEST(!pset.is_key_to_table("b11"));
+    BOOST_TEST(pset.to_string() == "b11:\"true\"");
+    BOOST_TEST(pset.get<bool>("b11"));
     pset.put<string>("b13", "\"false\"");
-    BOOST_CHECK_EQUAL(pset.to_string(), "b11:\"true\" b13:\"false\"");
-    BOOST_CHECK(!pset.get<bool>("b13"));
+    BOOST_TEST(pset.to_string() == "b11:\"true\" b13:\"false\"");
+    BOOST_TEST(!pset.get<bool>("b13"));
   }
 
   {
     ParameterSet pset;
     pset.put<bool>("b21", true);
-    BOOST_CHECK_EQUAL(pset.get<string>("b21"), "true");
-    BOOST_CHECK_EQUAL(pset.to_string(), "b21:true");
-    BOOST_CHECK(pset.get<bool>("b21"));
+    BOOST_TEST(pset.get<string>("b21") == "true");
+    BOOST_TEST(pset.to_string() == "b21:true");
+    BOOST_TEST(pset.get<bool>("b21"));
     pset.put<bool>("b24", false);
-    BOOST_CHECK_EQUAL(pset.get<string>("b24"), "false");
-    BOOST_CHECK_EQUAL(pset.to_string(), "b21:true b24:false");
-    BOOST_CHECK(!pset.get<bool>("b24"));
+    BOOST_TEST(pset.get<string>("b24") == "false");
+    BOOST_TEST(pset.to_string() == "b21:true b24:false");
+    BOOST_TEST(!pset.get<bool>("b24"));
   }
 
   {
     ParameterSet pset;
     pset.put<string>("b31", "tru");
-    BOOST_CHECK_EQUAL(pset.to_string(), "b31:\"tru\"");
+    BOOST_TEST(pset.to_string() == "b31:\"tru\"");
     BOOST_CHECK_THROW(pset.get<bool>("b31"), fhicl::exception);
   }
 }
@@ -71,12 +71,12 @@ BOOST_AUTO_TEST_CASE(nil_value) // test atom "nil"
   nil_t nil_value = 0;
 
   ParameterSet pset;
-  BOOST_CHECK(pset.is_empty());
-  BOOST_CHECK_EQUAL(pset.to_string(), "");
+  BOOST_TEST(pset.is_empty());
+  BOOST_TEST(pset.to_string() == "");
 
   pset.put<nil_t>("n11", 0);
-  BOOST_CHECK_EQUAL(pset.get<nil_t>("n11"), nil_value);
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:@nil");
+  BOOST_TEST(pset.get<nil_t>("n11") == nil_value);
+  BOOST_TEST(pset.to_string() == "n11:@nil");
   BOOST_CHECK_THROW(pset.get<bool>("n11"), fhicl::exception);
   BOOST_CHECK_THROW(pset.get<uint>("n11"), fhicl::exception);
   BOOST_CHECK_THROW(pset.get<int>("n11"), fhicl::exception);
@@ -87,42 +87,41 @@ BOOST_AUTO_TEST_CASE(nil_value) // test atom "nil"
 
   pset.put<string>("n21", "nil");
   BOOST_CHECK_THROW(pset.get<nil_t>("n21"), fhicl::exception);
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:@nil n21:\"nil\"");
+  BOOST_TEST(pset.to_string() == "n11:@nil n21:\"nil\"");
 
   pset.put<string>("n31", "NIL");
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:@nil n21:\"nil\" n31:\"NIL\"");
+  BOOST_TEST(pset.to_string() == "n11:@nil n21:\"nil\" n31:\"NIL\"");
   BOOST_CHECK_THROW(pset.get<nil_t>("n31"), fhicl::exception);
 
   ParameterSet pset2;
   make_ParameterSet(pset.to_string(), pset2);
-  BOOST_CHECK_EQUAL(pset.to_string(), pset2.to_string());
+  BOOST_TEST(pset.to_string() == pset2.to_string());
 
   ParameterSet pset3;
   make_ParameterSet("n11:@nil n21:nil n31:\"@nil\"", pset3);
-  BOOST_CHECK_EQUAL(pset3.to_string(), "n11:@nil n21:\"nil\" n31:\"@nil\"");
+  BOOST_TEST(pset3.to_string() == "n11:@nil n21:\"nil\" n31:\"@nil\"");
   BOOST_CHECK_THROW(pset3.get<string>("n11"), fhicl::exception);
-  BOOST_CHECK_EQUAL(pset3.get<string>("n21"), "nil");
-  BOOST_CHECK_EQUAL(pset3.get<string>("n31"), "@nil");
+  BOOST_TEST(pset3.get<string>("n21") == "nil");
+  BOOST_TEST(pset3.get<string>("n31") == "@nil");
 }
 
 BOOST_AUTO_TEST_CASE(string_values) // test string atoms
 {
   ParameterSet pset;
-  BOOST_CHECK(pset.is_empty());
+  BOOST_TEST(pset.is_empty());
 
   pset.put<string>("n11", "");
-  BOOST_CHECK_EQUAL(pset.get<string>("n11"), "");
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:\"\"");
+  BOOST_TEST(pset.get<string>("n11") == "");
+  BOOST_TEST(pset.to_string() == "n11:\"\"");
   pset.put<string>("n13", "a");
-  BOOST_CHECK_EQUAL(pset.get<string>("n13"), "a");
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:\"\" n13:\"a\"");
+  BOOST_TEST(pset.get<string>("n13") == "a");
+  BOOST_TEST(pset.to_string() == "n11:\"\" n13:\"a\"");
   pset.put<string>("n15", "\"a\"");
-  BOOST_CHECK_EQUAL(pset.get<string>("n15"), "a");
-  BOOST_CHECK_EQUAL(pset.to_string(), "n11:\"\" n13:\"a\" n15:\"a\"");
+  BOOST_TEST(pset.get<string>("n15") == "a");
+  BOOST_TEST(pset.to_string() == "n11:\"\" n13:\"a\" n15:\"a\"");
   pset.put<string>("n17", "'a b'");
-  BOOST_CHECK_EQUAL(pset.get<string>("n17"), "a b");
-  BOOST_CHECK_EQUAL(pset.to_string(),
-                    "n11:\"\" n13:\"a\" n15:\"a\" n17:\"a b\"");
+  BOOST_TEST(pset.get<string>("n17") == "a b");
+  BOOST_TEST(pset.to_string() == "n11:\"\" n13:\"a\" n15:\"a\" n17:\"a b\"");
 }
 
 BOOST_AUTO_TEST_CASE(unsigned_values) // test unsigned integral atoms
@@ -130,39 +129,39 @@ BOOST_AUTO_TEST_CASE(unsigned_values) // test unsigned integral atoms
   {
     ParameterSet pset;
     pset.put<uint>("u11", 0u);
-    BOOST_CHECK_EQUAL(pset.get<string>("u11"), "0");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u11:0");
-    BOOST_CHECK_EQUAL(pset.get<uint>("u11"), 0u);
+    BOOST_TEST(pset.get<string>("u11") == "0");
+    BOOST_TEST(pset.to_string() == "u11:0");
+    BOOST_TEST(pset.get<uint>("u11") == 0u);
   }
 
   {
     ParameterSet pset;
     pset.put<string>("u21", "000");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u21:\"000\"");
+    BOOST_TEST(pset.to_string() == "u21:\"000\"");
     uint u21 = pset.get<uint>("u21");
-    BOOST_CHECK_EQUAL(u21, 0u);
+    BOOST_TEST(u21 == 0u);
     pset.put<uint>("u23", u21);
-    BOOST_CHECK_EQUAL(pset.get<string>("u23"), "0");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u21:\"000\" u23:0");
+    BOOST_TEST(pset.get<string>("u23") == "0");
+    BOOST_TEST(pset.to_string() == "u21:\"000\" u23:0");
   }
 
   {
     ParameterSet pset;
     pset.put<string>("u31", "1.2e+1");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u31:\"1.2e+1\"");
-    BOOST_CHECK_EQUAL(pset.get<uint>("u31"), 12u);
+    BOOST_TEST(pset.to_string() == "u31:\"1.2e+1\"");
+    BOOST_TEST(pset.get<uint>("u31") == 12u);
   }
 
   {
     ParameterSet pset;
     pset.put<unsigned long>("u41", 123456ul);
-    BOOST_CHECK_EQUAL(pset.get<string>("u41"), "123456");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u41:123456");
-    BOOST_CHECK_EQUAL(pset.get<unsigned long>("u41"), 123456ul);
+    BOOST_TEST(pset.get<string>("u41") == "123456");
+    BOOST_TEST(pset.to_string() == "u41:123456");
+    BOOST_TEST(pset.get<unsigned long>("u41") == 123456ul);
     pset.put<unsigned long>("u44", 1234567ul);
-    BOOST_CHECK_EQUAL(pset.get<string>("u44"), "1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.to_string(), "u41:123456 u44:1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.get<unsigned long>("u44"), 1234567ul);
+    BOOST_TEST(pset.get<string>("u44") == "1.234567e+6");
+    BOOST_TEST(pset.to_string() == "u41:123456 u44:1.234567e+6");
+    BOOST_TEST(pset.get<unsigned long>("u44") == 1234567ul);
   }
 }
 
@@ -171,51 +170,51 @@ BOOST_AUTO_TEST_CASE(int_values) // test signed integral atoms
   {
     ParameterSet pset;
     pset.put<int>("i1", 0);
-    BOOST_CHECK_EQUAL(pset.get<string>("i1"), "0");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i1:0");
-    BOOST_CHECK_EQUAL(pset.get<int>("i1"), 0);
+    BOOST_TEST(pset.get<string>("i1") == "0");
+    BOOST_TEST(pset.to_string() == "i1:0");
+    BOOST_TEST(pset.get<int>("i1") == 0);
   }
 
   {
     ParameterSet pset;
     pset.put<string>("i21", "000");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i21:\"000\"");
+    BOOST_TEST(pset.to_string() == "i21:\"000\"");
     int i21 = pset.get<int>("i21");
-    BOOST_CHECK_EQUAL(i21, 0);
+    BOOST_TEST(i21 == 0);
     pset.put<int>("i23", i21);
-    BOOST_CHECK_EQUAL(pset.get<string>("i23"), "0");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i21:\"000\" i23:0");
+    BOOST_TEST(pset.get<string>("i23") == "0");
+    BOOST_TEST(pset.to_string() == "i21:\"000\" i23:0");
   }
 
   {
     ParameterSet pset;
     pset.put<string>("i31", "-1.2e+1");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i31:\"-1.2e+1\"");
-    BOOST_CHECK_EQUAL(pset.get<int>("i31"), -12);
+    BOOST_TEST(pset.to_string() == "i31:\"-1.2e+1\"");
+    BOOST_TEST(pset.get<int>("i31") == -12);
   }
 
   {
     ParameterSet pset;
     pset.put<long>("i41", 123456);
-    BOOST_CHECK_EQUAL(pset.get<string>("i41"), "123456");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i41:123456");
-    BOOST_CHECK_EQUAL(pset.get<long>("i41"), 123456);
+    BOOST_TEST(pset.get<string>("i41") == "123456");
+    BOOST_TEST(pset.to_string() == "i41:123456");
+    BOOST_TEST(pset.get<long>("i41") == 123456);
     pset.put<long>("i44", 1234567);
-    BOOST_CHECK_EQUAL(pset.get<string>("i44"), "1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i41:123456 i44:1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.get<long>("i44"), 1234567);
+    BOOST_TEST(pset.get<string>("i44") == "1.234567e+6");
+    BOOST_TEST(pset.to_string() == "i41:123456 i44:1.234567e+6");
+    BOOST_TEST(pset.get<long>("i44") == 1234567);
   }
 
   {
     ParameterSet pset;
     pset.put<long>("i51", -123456);
-    BOOST_CHECK_EQUAL(pset.get<string>("i51"), "-123456");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i51:-123456");
-    BOOST_CHECK_EQUAL(pset.get<long>("i51"), -123456);
+    BOOST_TEST(pset.get<string>("i51") == "-123456");
+    BOOST_TEST(pset.to_string() == "i51:-123456");
+    BOOST_TEST(pset.get<long>("i51") == -123456);
     pset.put<long>("i54", -1234567);
-    BOOST_CHECK_EQUAL(pset.get<string>("i54"), "-1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.to_string(), "i51:-123456 i54:-1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.get<long>("i54"), -1234567);
+    BOOST_TEST(pset.get<string>("i54") == "-1.234567e+6");
+    BOOST_TEST(pset.to_string() == "i51:-123456 i54:-1.234567e+6");
+    BOOST_TEST(pset.get<long>("i54") == -1234567);
   }
 }
 
@@ -224,43 +223,43 @@ BOOST_AUTO_TEST_CASE(float_values) // test floating-point atoms
   {
     ParameterSet pset;
     pset.put<dbl>("f11", 0.0);
-    BOOST_CHECK_EQUAL(pset.get<string>("f11"), "0");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f11:0");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f11"), 0.0);
-    BOOST_CHECK_EQUAL(pset.get<int>("f11"), 0);
-    BOOST_CHECK_EQUAL(pset.get<uint>("f11"), 0u);
+    BOOST_TEST(pset.get<string>("f11") == "0");
+    BOOST_TEST(pset.to_string() == "f11:0");
+    BOOST_TEST(pset.get<dbl>("f11") == 0.0);
+    BOOST_TEST(pset.get<int>("f11") == 0);
+    BOOST_TEST(pset.get<uint>("f11") == 0u);
     pset.put<dbl>("f14", 12.0);
-    BOOST_CHECK_EQUAL(pset.get<string>("f14"), "12");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f11:0 f14:12");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f14"), 12.0);
-    BOOST_CHECK_EQUAL(pset.get<int>("f14"), 12);
-    BOOST_CHECK_EQUAL(pset.get<uint>("f14"), 12u);
+    BOOST_TEST(pset.get<string>("f14") == "12");
+    BOOST_TEST(pset.to_string() == "f11:0 f14:12");
+    BOOST_TEST(pset.get<dbl>("f14") == 12.0);
+    BOOST_TEST(pset.get<int>("f14") == 12);
+    BOOST_TEST(pset.get<uint>("f14") == 12u);
     pset.put<dbl>("f17", 12.3e1);
-    BOOST_CHECK_EQUAL(pset.get<string>("f17"), "123");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f11:0 f14:12 f17:123");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f17"), 123.0);
-    BOOST_CHECK_EQUAL(pset.get<int>("f17"), 123);
-    BOOST_CHECK_EQUAL(pset.get<uint>("f17"), 123u);
+    BOOST_TEST(pset.get<string>("f17") == "123");
+    BOOST_TEST(pset.to_string() == "f11:0 f14:12 f17:123");
+    BOOST_TEST(pset.get<dbl>("f17") == 123.0);
+    BOOST_TEST(pset.get<int>("f17") == 123);
+    BOOST_TEST(pset.get<uint>("f17") == 123u);
   }
 
   {
     ParameterSet pset;
     pset.put<dbl>("f21", 12.3456e4);
-    BOOST_CHECK_EQUAL(pset.get<string>("f21"), "123456");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f21:123456");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f21"), 123456.0);
-    BOOST_CHECK_EQUAL(pset.get<int>("f21"), 123456);
-    BOOST_CHECK_EQUAL(pset.get<uint>("f21"), 123456u);
+    BOOST_TEST(pset.get<string>("f21") == "123456");
+    BOOST_TEST(pset.to_string() == "f21:123456");
+    BOOST_TEST(pset.get<dbl>("f21") == 123456.0);
+    BOOST_TEST(pset.get<int>("f21") == 123456);
+    BOOST_TEST(pset.get<uint>("f21") == 123456u);
     pset.put<dbl>("f24", 12.34567e5);
-    BOOST_CHECK_EQUAL(pset.get<string>("f24"), "1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f21:123456 f24:1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f24"), 1234567.0);
-    BOOST_CHECK_EQUAL(pset.get<int>("f24"), 1234567L);
-    BOOST_CHECK_EQUAL(pset.get<uint>("f24"), 1234567uL);
+    BOOST_TEST(pset.get<string>("f24") == "1.234567e+6");
+    BOOST_TEST(pset.to_string() == "f21:123456 f24:1.234567e+6");
+    BOOST_TEST(pset.get<dbl>("f24") == 1234567.0);
+    BOOST_TEST(pset.get<int>("f24") == 1234567L);
+    BOOST_TEST(pset.get<uint>("f24") == 1234567uL);
     pset.put<dbl>("f27", 3.5);
-    BOOST_CHECK_EQUAL(pset.get<string>("f27"), "3.5");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f21:123456 f24:1.234567e+6 f27:3.5");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f27"), 3.5);
+    BOOST_TEST(pset.get<string>("f27") == "3.5");
+    BOOST_TEST(pset.to_string() == "f21:123456 f24:1.234567e+6 f27:3.5");
+    BOOST_TEST(pset.get<dbl>("f27") == 3.5);
     BOOST_CHECK_THROW(pset.get<int>("f27"), fhicl::exception);
     BOOST_CHECK_THROW(pset.get<uint>("f27"), fhicl::exception);
   }
@@ -268,29 +267,26 @@ BOOST_AUTO_TEST_CASE(float_values) // test floating-point atoms
   {
     ParameterSet pset;
     pset.put<dbl>("f31", -12.3456e4);
-    BOOST_CHECK_EQUAL(pset.get<string>("f31"), "-123456");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f31:-123456");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f31"), -123456.0);
+    BOOST_TEST(pset.get<string>("f31") == "-123456");
+    BOOST_TEST(pset.to_string() == "f31:-123456");
+    BOOST_TEST(pset.get<dbl>("f31") == -123456.0);
     pset.put<dbl>("f34", -12.34567e5);
-    BOOST_CHECK_EQUAL(pset.get<string>("f34"), "-1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f31:-123456 f34:-1.234567e+6");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f34"), -1234567.0);
+    BOOST_TEST(pset.get<string>("f34") == "-1.234567e+6");
+    BOOST_TEST(pset.to_string() == "f31:-123456 f34:-1.234567e+6");
+    BOOST_TEST(pset.get<dbl>("f34") == -1234567.0);
     pset.put<dbl>("f37", -12.34567e-5);
-    // BOOST_CHECK_EQUAL( pset.get<string>("f37"), "-1.234567e-4" );
-    // BOOST_CHECK_EQUAL( pset.to_string(), "f31:-123456 f34:-1.234567e+6
-    // f37:-1.234567e-4" );
   }
 
   {
     ParameterSet pset;
     pset.put<dbl>("f41", numeric_limits<dbl>::infinity());
-    BOOST_CHECK_EQUAL(pset.get<string>("f41"), "+infinity");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f41:+infinity");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f41"), numeric_limits<dbl>::infinity());
+    BOOST_TEST(pset.get<string>("f41") == "+infinity");
+    BOOST_TEST(pset.to_string() == "f41:+infinity");
+    BOOST_TEST(pset.get<dbl>("f41") == numeric_limits<dbl>::infinity());
     pset.put<dbl>("f44", -numeric_limits<dbl>::infinity());
-    BOOST_CHECK_EQUAL(pset.get<string>("f44"), "-infinity");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f41:+infinity f44:-infinity");
-    BOOST_CHECK_EQUAL(pset.get<dbl>("f44"), -numeric_limits<dbl>::infinity());
+    BOOST_TEST(pset.get<string>("f44") == "-infinity");
+    BOOST_TEST(pset.to_string() == "f41:+infinity f44:-infinity");
+    BOOST_TEST(pset.get<dbl>("f44") == -numeric_limits<dbl>::infinity());
   }
 }
 
@@ -299,24 +295,24 @@ BOOST_AUTO_TEST_CASE(complex_values) // test complex atoms
   {
     ParameterSet pset;
     pset.put<cldbl>("f11", cldbl());
-    BOOST_CHECK_EQUAL(pset.get<string>("f11"), "(0,0)");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f11:(0,0)");
-    BOOST_CHECK_EQUAL(pset.get<cldbl>("f11"), cldbl(0.0L, 0.0L));
+    BOOST_TEST(pset.get<string>("f11") == "(0,0)");
+    BOOST_TEST(pset.to_string() == "f11:(0,0)");
+    BOOST_TEST(pset.get<cldbl>("f11") == cldbl(0.0L, 0.0L));
     pset.put<cdbl>("f14", cdbl());
-    BOOST_CHECK_EQUAL(pset.get<string>("f14"), "(0,0)");
-    BOOST_CHECK_EQUAL(pset.to_string(), "f11:(0,0) f14:(0,0)");
-    BOOST_CHECK_EQUAL(pset.get<cdbl>("f14"), cdbl(0.0, 0.0));
+    BOOST_TEST(pset.get<string>("f14") == "(0,0)");
+    BOOST_TEST(pset.to_string() == "f11:(0,0) f14:(0,0)");
+    BOOST_TEST(pset.get<cdbl>("f14") == cdbl(0.0, 0.0));
   }
 
   {
     ParameterSet pset;
     pset.put<cldbl>("f21", cldbl(1, 2));
-    BOOST_CHECK_EQUAL(pset.to_string(), "f21:(1,2)");
-    BOOST_CHECK_EQUAL(pset.get<cldbl>("f21"), cldbl(1.0L, 2.0L));
-    BOOST_CHECK_EQUAL(pset.get<cdbl>("f21"), cdbl(1.0, 2.0));
+    BOOST_TEST(pset.to_string() == "f21:(1,2)");
+    BOOST_TEST(pset.get<cldbl>("f21") == cldbl(1.0L, 2.0L));
+    BOOST_TEST(pset.get<cdbl>("f21") == cdbl(1.0, 2.0));
     pset.put<string>("f24", "(3.25 , 4.75 )");
-    BOOST_CHECK_EQUAL(pset.get<cldbl>("f24"), cldbl(3.25L, 4.75L));
-    BOOST_CHECK_EQUAL(pset.get<cdbl>("f24"), cdbl(3.25, 4.75));
+    BOOST_TEST(pset.get<cldbl>("f24") == cldbl(3.25L, 4.75L));
+    BOOST_TEST(pset.get<cdbl>("f24") == cdbl(3.25, 4.75));
   }
 }
 
@@ -326,92 +322,91 @@ BOOST_AUTO_TEST_CASE(sequence_values) // test sequences
   uvec uv;
 
   pset.put<string>("f11", "[]");
-  BOOST_CHECK_EQUAL(pset.get<string>("f11"), "[]");
-  BOOST_CHECK_EQUAL(pset.to_string(), "f11:\"[]\"");
-  BOOST_CHECK(pset.get<uvec>("f11").empty());
-  BOOST_CHECK(pset.get<uvec>("f11") == uvec());
-  BOOST_CHECK(pset.get<uvec>("f11") == uv);
+  BOOST_TEST(pset.get<string>("f11") == "[]");
+  BOOST_TEST(pset.to_string() == "f11:\"[]\"");
+  BOOST_TEST(pset.get<uvec>("f11").empty());
+  BOOST_TEST(pset.get<uvec>("f11") == uvec());
+  BOOST_TEST(pset.get<uvec>("f11") == uv);
   pset.put<uvec>("f16", uv);
-  // BOOST_CHECK_EQUAL( pset.get<string>("f16", "NO"), "NO" );
-  BOOST_CHECK_EQUAL(pset.to_string(), "f11:\"[]\" f16:[]");
-  BOOST_CHECK(pset.get<uvec>("f16") == uv);
+  // BOOST_TEST( pset.get<string>("f16", "NO") ==  "NO" );
+  BOOST_TEST(pset.to_string() == "f11:\"[]\" f16:[]");
+  BOOST_TEST(pset.get<uvec>("f16") == uv);
 
   uv.push_back(1);
   pset.put<string>("f21", "[1]");
-  BOOST_CHECK_EQUAL(pset.get<string>("f21"), "[1]");
-  BOOST_CHECK_EQUAL(pset.to_string(), "f11:\"[]\" f16:[] f21:\"[1]\"");
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f21").size(), 1u);
-  BOOST_CHECK(pset.get<uvec>("f21") == uv);
+  BOOST_TEST(pset.get<string>("f21") == "[1]");
+  BOOST_TEST(pset.to_string() == "f11:\"[]\" f16:[] f21:\"[1]\"");
+  BOOST_TEST(pset.get<uvec>("f21").size() == 1u);
+  BOOST_TEST(pset.get<uvec>("f21") == uv);
   pset.put<uvec>("f25", uv);
-  // BOOST_CHECK_EQUAL( pset.get<string>("f25", "NO"), "NO" );
-  BOOST_CHECK_EQUAL(pset.to_string(), "f11:\"[]\" f16:[] f21:\"[1]\" f25:[1]");
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f25").size(), 1u);
-  BOOST_CHECK(pset.get<uvec>("f25") == uv);
+  // BOOST_TEST( pset.get<string>("f25", "NO") ==  "NO" );
+  BOOST_TEST(pset.to_string() == "f11:\"[]\" f16:[] f21:\"[1]\" f25:[1]");
+  BOOST_TEST(pset.get<uvec>("f25").size() == 1u);
+  BOOST_TEST(pset.get<uvec>("f25") == uv);
 
   uv.push_back(2);
   pset.put<string>("f31", "[1,2]");
-  BOOST_CHECK_EQUAL(pset.get<string>("f31"), "[1,2]");
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f31").size(), 2u);
-  BOOST_CHECK(pset.get<uvec>("f31") == uv);
+  BOOST_TEST(pset.get<string>("f31") == "[1,2]");
+  BOOST_TEST(pset.get<uvec>("f31").size() == 2u);
+  BOOST_TEST(pset.get<uvec>("f31") == uv);
   uv.push_back(3);
   pset.put<uvec>("f34", uv);
-  BOOST_CHECK_EQUAL(
-    pset.to_string(),
-    "f11:\"[]\" f16:[] f21:\"[1]\" f25:[1] f31:\"[1,2]\" f34:[1,2,3]");
-  // BOOST_CHECK_EQUAL( pset.get<string>("f34", "NO"), "NO" );
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f34").size(), 3u);
-  BOOST_CHECK(pset.get<uvec>("f34") == uv);
+  BOOST_TEST(pset.to_string() ==
+             "f11:\"[]\" f16:[] f21:\"[1]\" f25:[1] f31:\"[1,2]\" f34:[1,2,3]");
+  // BOOST_TEST( pset.get<string>("f34", "NO") ==  "NO" );
+  BOOST_TEST(pset.get<uvec>("f34").size() == 3u);
+  BOOST_TEST(pset.get<uvec>("f34") == uv);
 
   uv.push_back(4);
   pset.put<string>("f41", "[1,2,3,4]");
-  BOOST_CHECK_EQUAL(pset.get<string>("f41"), "[1,2,3,4]");
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f41").size(), 4u);
-  BOOST_CHECK(pset.get<uvec>("f41") == uv);
+  BOOST_TEST(pset.get<string>("f41") == "[1,2,3,4]");
+  BOOST_TEST(pset.get<uvec>("f41").size() == 4u);
+  BOOST_TEST(pset.get<uvec>("f41") == uv);
   uv.push_back(5);
   pset.put<uvec>("f43", uv);
-  BOOST_CHECK(pset.is_key_to_sequence("f43"));
-  BOOST_CHECK(!pset.is_key_to_table("f43"));
-  BOOST_CHECK(!pset.is_key_to_atom("f43"));
-  // BOOST_CHECK_EQUAL( pset.get<string>("f43", "NO"), "NO" );
-  BOOST_CHECK_EQUAL(pset.get<uvec>("f43").size(), 5u);
-  BOOST_CHECK(pset.get<uvec>("f43") == uv);
+  BOOST_TEST(pset.is_key_to_sequence("f43"));
+  BOOST_TEST(!pset.is_key_to_table("f43"));
+  BOOST_TEST(!pset.is_key_to_atom("f43"));
+  // BOOST_TEST( pset.get<string>("f43", "NO") ==  "NO" );
+  BOOST_TEST(pset.get<uvec>("f43").size() == 5u);
+  BOOST_TEST(pset.get<uvec>("f43") == uv);
 }
 
 BOOST_AUTO_TEST_CASE(table_values) // test tables
 {
   ParameterSet p0;
-  BOOST_CHECK_EQUAL(p0.to_string(), "");
+  BOOST_TEST(p0.to_string() == "");
   BOOST_CHECK_THROW(p0.get<string>("a"), fhicl::exception);
 
   ParameterSet p1;
   p1.put<string>("b", "B");
   p1.put<string>("a", "A");
-  BOOST_CHECK_EQUAL(p1.get<string>("a"), "A");
-  BOOST_CHECK_EQUAL(p1.get<string>("b"), "B");
-  BOOST_CHECK_EQUAL(p1.to_string(), "a:\"A\" b:\"B\"");
+  BOOST_TEST(p1.get<string>("a") == "A");
+  BOOST_TEST(p1.get<string>("b") == "B");
+  BOOST_TEST(p1.to_string() == "a:\"A\" b:\"B\"");
 
   ParameterSet p2;
   p2.put<string>("y", "Y");
   p2.put<string>("z", "Z");
   p2.put<string>("x", "X");
-  BOOST_CHECK_EQUAL(p2.get<string>("x"), "X");
-  BOOST_CHECK_EQUAL(p2.get<string>("y"), "Y");
-  BOOST_CHECK_EQUAL(p2.get<string>("z"), "Z");
-  BOOST_CHECK_EQUAL(p2.to_string(), "x:\"X\" y:\"Y\" z:\"Z\"");
+  BOOST_TEST(p2.get<string>("x") == "X");
+  BOOST_TEST(p2.get<string>("y") == "Y");
+  BOOST_TEST(p2.get<string>("z") == "Z");
+  BOOST_TEST(p2.to_string() == "x:\"X\" y:\"Y\" z:\"Z\"");
 
   ParameterSet p3;
   p3.put<ParameterSet>("p2", p2);
   p3.put<ParameterSet>("p1", p1);
-  BOOST_CHECK(p3.is_key_to_table("p2"));
-  BOOST_CHECK(!p3.is_key_to_sequence("p2"));
-  BOOST_CHECK(!p3.is_key_to_atom("p2"));
-  BOOST_CHECK_EQUAL(p3.get<ParameterSet>("p1").get<string>("a"), "A");
-  BOOST_CHECK_EQUAL(p3.get<ParameterSet>("p1").get<string>("b"), "B");
-  BOOST_CHECK_EQUAL(p3.get<ParameterSet>("p2").get<string>("x"), "X");
-  BOOST_CHECK_EQUAL(p3.get<ParameterSet>("p2").get<string>("y"), "Y");
-  BOOST_CHECK_EQUAL(p3.get<ParameterSet>("p2").get<string>("z"), "Z");
-  BOOST_CHECK_EQUAL(p3.to_string(),
-                    "p1:{a:\"A\" b:\"B\"} p2:{x:\"X\" y:\"Y\" z:\"Z\"}");
+  BOOST_TEST(p3.is_key_to_table("p2"));
+  BOOST_TEST(!p3.is_key_to_sequence("p2"));
+  BOOST_TEST(!p3.is_key_to_atom("p2"));
+  BOOST_TEST(p3.get<ParameterSet>("p1").get<string>("a") == "A");
+  BOOST_TEST(p3.get<ParameterSet>("p1").get<string>("b") == "B");
+  BOOST_TEST(p3.get<ParameterSet>("p2").get<string>("x") == "X");
+  BOOST_TEST(p3.get<ParameterSet>("p2").get<string>("y") == "Y");
+  BOOST_TEST(p3.get<ParameterSet>("p2").get<string>("z") == "Z");
+  BOOST_TEST(p3.to_string() ==
+             "p1:{a:\"A\" b:\"B\"} p2:{x:\"X\" y:\"Y\" z:\"Z\"}");
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/fhiclcpp/types/ConfigurationTable.h b/fhiclcpp/types/ConfigurationTable.h
index 1b2afdf..6b47e55 100644
--- a/fhiclcpp/types/ConfigurationTable.h
+++ b/fhiclcpp/types/ConfigurationTable.h
@@ -1,5 +1,5 @@
-#ifndef fhicl_Utilities_ConfigurationTable_h
-#define fhicl_Utilities_ConfigurationTable_h
+#ifndef fhiclcpp_types_ConfigurationTable_h
+#define fhiclcpp_types_ConfigurationTable_h
 
 #include "cetlib/exempt_ptr.h"
 #include "fhiclcpp/types/Table.h"
@@ -55,4 +55,4 @@ namespace fhicl {
 // Local variables:
 // mode: c++
 // End:
-#endif /* fhicl_Utilities_ConfigurationTable_h */
+#endif /* fhiclcpp_types_ConfigurationTable_h */
diff --git a/fhiclcpp/types/MaybeUseFunction.h b/fhiclcpp/types/MaybeUseFunction.h
index b735053..0ef4a6b 100644
--- a/fhiclcpp/types/MaybeUseFunction.h
+++ b/fhiclcpp/types/MaybeUseFunction.h
@@ -12,3 +12,7 @@ namespace fhicl {
 }
 
 #endif /* fhiclcpp_types_MaybeUseFunction_h */
+
+// Local Variables:
+// mode: c++
+// End:
diff --git a/fhiclcpp/types/OptionalSequence.h b/fhiclcpp/types/OptionalSequence.h
index 18bd0da..3f87631 100644
--- a/fhiclcpp/types/OptionalSequence.h
+++ b/fhiclcpp/types/OptionalSequence.h
@@ -55,7 +55,7 @@ namespace fhicl {
     }
 
     bool
-    hasValue() const
+    hasValue() const noexcept
     {
       return has_value_;
     }
@@ -130,6 +130,12 @@ namespace fhicl {
       return true;
     }
 
+    bool
+    hasValue() const noexcept
+    {
+      return has_value_;
+    }
+
   private:
     ftype value_;
     bool has_value_{false};
diff --git a/fhiclcpp/types/Sequence.h b/fhiclcpp/types/Sequence.h
index 889c66f..bd7e54f 100644
--- a/fhiclcpp/types/Sequence.h
+++ b/fhiclcpp/types/Sequence.h
@@ -221,8 +221,7 @@ namespace fhicl {
         }
 
         for (auto i = value_.size(); i != n; ++i) {
-          value_.emplace_back(
-            new tt::fhicl_type<T>{Name::sequence_element(key_fragment, i)});
+          value_.push_back(std::make_shared<tt::fhicl_type<T>>(Name::sequence_element(key_fragment, i)));
         }
       }
     }
@@ -415,7 +414,7 @@ namespace fhicl {
     static_assert(!tt::is_table_v<T>, NO_DEFAULTS_FOR_TABLE);
     std::size_t i{};
     for (auto const& t : defaults) {
-      value_.emplace_back(new tt::fhicl_type<T>{Name::sequence_element(i), t});
+      value_.push_back(std::make_shared<tt::fhicl_type<T>>(Name::sequence_element(i), t));
       ++i;
     }
     NameStackRegistry::end_of_ctor();
@@ -436,7 +435,7 @@ namespace fhicl {
     static_assert(!tt::is_table_v<T>, NO_DEFAULTS_FOR_TABLE);
     std::size_t i{};
     for (auto const& t : defaults) {
-      value_.emplace_back(new tt::fhicl_type<T>{Name::sequence_element(i), t});
+      value_.emplace_back(std::make_shared<tt::fhicl_type<T>>(Name::sequence_element(i), t));
       ++i;
     }
     NameStackRegistry::end_of_ctor();
diff --git a/fhiclcpp/types/detail/check_nargs_for_bounded_sequences.h b/fhiclcpp/types/detail/check_nargs_for_bounded_sequences.h
index 1b0992d..0550071 100644
--- a/fhiclcpp/types/detail/check_nargs_for_bounded_sequences.h
+++ b/fhiclcpp/types/detail/check_nargs_for_bounded_sequences.h
@@ -10,7 +10,7 @@ namespace fhicl::detail {
                                          std::size_t provided);
 }
 
-#endif
+#endif /* fhiclcpp_types_detail_check_nargs_for_bounded_sequences_h */
 
 // Local variables:
 // mode: c++
diff --git a/ups/product_deps b/ups/product_deps
index 87d64cb..4d403ed 100644
--- a/ups/product_deps
+++ b/ups/product_deps
@@ -1,4 +1,4 @@
-parent fhiclcpp v4_11_00
+parent fhiclcpp v4_11_01
 defaultqual e19
 #
 fcldir -
@@ -10,12 +10,12 @@ table_fragment_end
 #
 # define product/version pairs
 product         version
-cetlib          v3_09_00
+cetlib          v3_10_00
 pybind11        v2_2_4
 python          v3_7_2          -default-
 python          v2_7_15a        py2
 
-cetbuildtools   v7_14_00        -       only_for_build
+cetbuildtools   v7_15_01        -       only_for_build
 end_product_list
 
 table_fragment_begin
diff --git a/xcompile/CMakeLists.txt b/xcompile/CMakeLists.txt
index 16af271..75d6b3d 100644
--- a/xcompile/CMakeLists.txt
+++ b/xcompile/CMakeLists.txt
@@ -1,4 +1,4 @@
 install (FILES
     LinuxPPC.cmake
-    DESTINATION ${product}/${version}/src/xcompile
+    DESTINATION src/xcompile
     )
